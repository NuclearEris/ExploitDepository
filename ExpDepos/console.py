#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/10/18 11:21
"""
import os
import sys
import cmd
import mmh3
import base64
import codecs
import hashlib
import _thread
from time import sleep
import ExpDepos.libs.core.Request as Request

try:
    import ExpDepos
except ImportError:
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))

from ExpDepos.libs.core.common.Common import *
from ExpDepos.libs.core.ModuleLoader import ModuleLoader
from ExpDepos.libs.core.common.ExpPrompt import ExpPrompt


def parse(arg):
    return tuple(arg.split())


def parseValue(value: str):
    if value.isnumeric():
        return int(value)
    if value.lower() == "false":
        return False
    if value.lower() == "true":
        return True
    return value


def complete_process(text, line, begidx, endidx, shortList):
    if text or line:
        currentMakeup = line[line.rindex(" ") + 1:]
        offs = len(currentMakeup) - len(text)
        return [command[offs:] for command in shortList
                if command.startswith(currentMakeup)]
    else:
        return shortList


def format_module_path(module_info_path):
    modulePath = "modules" + os.sep + module_info_path
    return modulePath.replace("/", os.sep)


def print_doc_header(*args, style="cyan", dash="=", tab_gap_len=4, prefix=""):
    """
    打印命令行格式化文档输出标题

    :param args: 格式化文档内容
    :param style: 颜色样式 默认cyan
    :param dash: 下划线字符 默认“=”
    :param tab_gap_len: 制表符间隔长度 默认4
    :param prefix: 前缀内容
    :return:
    """
    if dash:
        console.print("")
    console.print("[{style}]".format(style=style) + prefix +
                  ("\t" * tab_gap_len).join(args) +
                  "[/{style}]".format(style=style))
    if dash:
        dash_args = tuple(dash * len(doc) for doc in args)
        # 打印下划线的时候置空dash 以此做判断依据 防止死循环
        print_doc_header(*dash_args, dash="", style=style, tab_gap_len=tab_gap_len, prefix=prefix)


def silentConsole(method):
    """
    实现Console默认无debug信息输出的装饰器

    :param method: 被装饰的do_command函数
    :return:
    """

    @wraps(method)
    def wrapper(self, *args, **kwargs):
        tmpMsgLevel = console.getMsgLevel()
        debugLevel = console.levels.get("DEBUG")["level"]
        # 只有在用户未主动设置debug模式且当前消息等级大于等于debug等级才更改
        if not self.debug and tmpMsgLevel >= debugLevel:
            console.setMsgLeve(debugLevel - 1)
        method(self, *args, **kwargs)
        console.setMsgLeve(tmpMsgLevel)

    return wrapper


def processScf(action="init"):
    if not env.Config.CloudFunctions:
        console.error("未找到云函数相关配置信息, 请在config中配置.")
        return
    if action == "init":
        scfInit(env.Config.CloudFunctions)
    if action == "clear":
        scfclear(env.Config.CloudFunctions)
    if action == "reset":
        if scfclear(env.Config.CloudFunctions):
            scfInit(env.Config.CloudFunctions)


class consoleShell(cmd.Cmd):
    intro = '[green]Welcome to the ExpDepose shell.' \
            ' Type [bold yellow]help[/bold yellow] or [bold yellow]?[/bold yellow] to list commands.\n[green]'
    prompt = '[bold red3]ExpDepos>[bold red3]'
    nohelp = "[yellow]没有命令: [/yellow][bold green]%s[/bold green] [yellow]的帮助信息[/yellow]"

    def __init__(self):
        super().__init__()
        self.request = Request.instance(env.CliOptions)
        self.modules = env.modules
        self.currentModule = None
        self.currentMsgLevel = None
        self.debug = False
        self.globalOpt = ['verbose', 'host', 'useScf', 'auth', 'cookie', 'headers', 'agent',
                          'referer', 'timeout', 'retries', 'rdelay', 'delay', 'proxy', 'thread']
        self.commands = {"Core Commands": {'?': '打印命令帮助',
                                           'help': '等同 ? 命令',
                                           'setg': '设置全局参数值',
                                           'get': '获取参数值',
                                           'show': '显示给定类型的模块信息或者全部模块',
                                           'debug': '设置Console输出为Debug模式',
                                           'undebug': '设置Console输出为非Debug模式',
                                           'exit': '退出Console'},
                         "Module Commands": {'use': '通过模块别名或路径选择使用的模块',
                                             'set': '设置模块参数值',
                                             'run': '执行已选中的模块(默认verify模式)',
                                             'exploit': '以exploit模式运行模块',
                                             'verify': '以verify模式运行模块',
                                             'info': '显示模块详细信息'},
                         "Cloud Functions": {
                             'scfinit': '初始化云函数',
                             'scfcls': '删除全部云函数',
                             'scfrst': '重置云函数'},
                         "Tools Functions": {
                             'md5': 'md5加密工具',
                             'base64': 'base64加密',
                             'mmh3': 'mmh3加密',
                             'hex': 'hex编码',
                             'unhex': 'hex解码'
                         },
                         "Debug Commands": {
                             'reload': '重载并应用consoleShell模块的代码更改'}
                         }
        self.subCmd_show = ['info', 'modules', 'alias', 'options', "fps"]
        self.module_info = None

    def getModuleFiles(self) -> list:
        """
        获取所有模块路径

        :return: list
        """
        return [module["path"] for module in self.modules]

    def getModuleAlias(self) -> list:
        """
        获取所有模块别名

        :return: list
        """
        return [module["Alias"] for module in self.modules]

    def getModuleInfoByArg(self, arg) -> dict:
        """
        根据 arg 值匹配路径或者别名的模块

        :param arg: 关键字
        :return: dict 已加载的模块信息
        """
        for module in self.modules:
            if module["path"] == arg or module["path"] in arg or module['Alias'] == arg:
                return module

    @silentConsole
    def do_use(self, arg):
        if arg in self.getModuleFiles() or arg in self.getModuleAlias():
            module_info = self.getModuleInfoByArg(arg)
            if module_info["isLoad"]:
                self.currentModule = module_info["module"]
            else:
                self.currentModule = self.loadModule(module_info)
        else:
            console.warning("无法使用模块 [royal_blue1]{0}[/royal_blue1], 请确认模块路径是否正确.".format(arg))

    def complete_use(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.getModuleFiles())

    @silentConsole
    def do_info(self, arg):
        module = None
        if arg:
            if arg in self.getModuleFiles() or arg in self.getModuleAlias():
                module_info = self.getModuleInfoByArg(arg)
                if module_info["isLoad"]:
                    module = module_info["module"]
                else:
                    module = self.loadModule(module_info)
            else:
                console.warning("无法查看模块 [royal_blue1]{0}[/royal_blue1] 信息, 请确认模块路径是否正确.".format(arg))
        else:
            if self.currentModule:
                module = self.currentModule
            else:
                console.warning("请选择需要查看的模块或使用 [bold green]help info[/bold green] 查看命令帮助.")
        if module:
            ModuleLoader.show_module_info(module)

    def complete_info(self, text, line, begidx, endidx):
        return self.complete_use(text, line, begidx, endidx)

    @silentConsole
    def do_set(self, arg):
        args = parse(arg)
        if len(args) >= 1:
            if self.currentModule:
                option_list = self.currentModule.get_allOpts()
                if args[0].lower() in option_list:
                    if len(args) >= 2:
                        self.currentModule.set_option(args[0].lower(), " ".join(args[1:]))
                        console.print(args[0] + " ==> " + " ".join(args[1:]))
                    else:
                        console.print("[yellow]set 命令错误 请提供参数值[/yellow]")
                elif args[0].lower() in self.globalOpt:
                    self.do_setg(arg)
                else:
                    console.print("[yellow]不存在的模块参数: {0}[/yellow]".format(args[0]))
            else:
                self.do_setg(arg)
        else:
            self.do_help("set")

    def complete_set(self, text, line, begidx, endidx):
        if self.currentModule:
            option_list = [key.upper() for key in self.currentModule.get_allOpts()]
        else:
            option_list = [key.upper() for key in self.globalOpt]
        return complete_process(text, line, begidx, endidx, option_list)

    @silentConsole
    def do_get(self, arg):
        value = None
        if arg == "USESCF":
            optName = "useScf"
        else:
            optName = arg.lower()
        try:
            if optName in self.globalOpt:
                value = getattr(env.CliOptions, optName)
            if self.currentModule and optName in self.currentModule.get_allOpts():
                value = self.currentModule.get_option(optName)
        except Exception as e:
            console.warning("无法获取参数值: {0}".format(e.args[0]))
        console.print(arg + " ==> " + str(value))

    def complete_get(self, text, line, begidx, endidx):
        short_list = self.globalOpt
        if self.currentModule:
            allOpts = self.currentModule.get_allOpts()
            short_list.extend(allOpts)
        return complete_process(text, line, begidx, endidx, [key.upper() for key in short_list])

    @silentConsole
    def do_setg(self, arg):
        arg = parse(arg)
        if len(arg) >= 1:
            if arg[0] == "USESCF":
                optName = "useScf"
            else:
                optName = arg[0].lower()
            if optName in self.globalOpt:
                if len(arg) >= 2:
                    setattr(env.CliOptions, optName, parseValue(" ".join(arg[1:])))
                    if optName == "verbose":
                        console.setMsgLeve(parseValue(arg[1:]))
                        console.setLogLevel(parseValue(arg[1:]))
                    if optName == "host" and self.currentModule:
                        self.currentModule.add_host(arg[1])
                    console.print("{0} ==> {1}".format(arg[0], " ".join(arg[1:])))
                else:
                    console.print("[yellow]setg 命令错误 请提供参数值[/yellow]")
            else:
                console.print("[yellow]不存在的全局参数: [/yellow][bold green] %s [/bold green]" % arg[0])
        else:
            self.do_help("setg")

    def complete_setg(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, [key.upper() for key in self.globalOpt])

    @silentConsole
    def do_show(self, arg):
        if arg in self.subCmd_show:
            subShowFunc = getattr(self, 'show_' + arg)
            subShowFunc()
        else:
            console.print("[yellow]无效的命令参数：[bold green]{0}[/bold green][/yellow]".format(arg))

    def show_info(self):
        self.do_info('')

    def show_modules(self):
        print_doc_header("List All Modules")
        ModuleLoader.list_modules("modules", self.modules)

    def show_alias(self):
        print_doc_header("List All Aliases")
        ModuleLoader.list_modules("alias", self.modules)

    def show_fps(self):
        print_doc_header("List All fingerprints")
        ModuleLoader.list_modules("fps", env.fps)

    def show_options(self):
        if self.currentModule:
            module_info = ModuleLoader.get_module_info(self.currentModule)
            options_info = module_info.pop("options_info")
            print_doc_header("List Module Options")
            ModuleLoader.show_options(self.currentModule, options_info)
        else:
            console.print("[yellow]当前无已选模块, 请先选择使用模块.[/yellow]")

    def complete_show(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.subCmd_show)

    def do_md5(self, arg):
        self.encrypt('md5', arg)

    def do_base64(self, arg):
        self.encrypt('base64', arg)

    def do_mmh3(self, arg):
        self.encrypt('mmh3', arg)

    def do_hex(self, arg):
        self.encrypt('hex', arg)

    def do_unhex(self, arg):
        self.encrypt("unhex", arg)

    def encrypt(self, method, arg):
        args = cli2args(arg.split())
        decrypt = False
        if "-d" in args:
            args = args[args.index("-d") + 1:]
            decrypt = True
        arg_str = "".join(args)
        if "url" in arg_str:
            url = arg_str[arg_str.index(":") + 1:]
            response = self.request.get(url)
            content = response.content
        else:
            content = bytes(arg_str.encode("UTF-8"))
        if method == "md5":
            console.print("md5: " + hashlib.md5(content).hexdigest())
        if method == "base64":
            if not decrypt:
                console.print("base64: " + base64.b64encode(content).decode())
            else:
                console.print("base64: " + base64.b64decode(content).decode())
        if method == "mmh3":
            console.print("mmh3: {0}".format(mmh3.hash(codecs.lookup('base64').encode(content)[0])))
        if method == "hex":
            if not decrypt:
                console.print("hex: 0x" + "".join([hexStr[2:] for hexStr in [hex(x) for x in content]]))
            else:
                content = content.decode("utf-8")
                if content.startswith("0x"):
                    content = content[2:]
                console.print("".join([chr(int(hexStr, 16)) for hexStr in
                                       [''.join(content[i:i + 2]) for i in range(0, len(content), 2)]]))
        if method == "unhex":
            content = content.decode("utf-8")
            if content.startswith("0x"):
                content = content[2:]
            console.print("".join([chr(int(hexStr, 16)) for hexStr in
                                   [''.join(content[i:i + 2]) for i in range(0, len(content), 2)]]))

    @silentConsole
    def do_debug(self, arg):
        """设置Console输出为Debug模式"""
        self.currentMsgLevel = console.getMsgLevel()
        debugLevel = console.levels.get("DEBUG")["level"]
        self.do_setg(arg="verbose {0}".format(debugLevel))
        self.debug = True

    @silentConsole
    def do_undebug(self, arg):
        """解除Console的Debug模式"""
        debugLevel = console.levels.get("DEBUG")["level"]
        if console.getMsgLevel() >= debugLevel:
            if self.currentMsgLevel and self.currentMsgLevel < debugLevel:
                msgLevel = self.currentMsgLevel
            else:
                msgLevel = debugLevel - 1
            self.do_setg(arg="verbose " + str(msgLevel))
            self.debug = False

    @silentConsole
    def do_run(self, arg: str):
        mode = "verify"
        backend = False
        args = cli2args(arg.split())
        if "-b" in args:
            backend = True
        if "--mode" in args:
            mode = args[args.index("--mode") + 1]
        allOpts = self.currentModule.get_allOpts()
        # 根据模块所有自定义参数遍历arg中的参数并重组成字符串
        arg = " ".join(["--" + option + " " + add_quote(args[args.index("--" + option) + 1])
                        for option in allOpts if "--" + option in args])
        self.module_run(arg, backend=backend, mode=mode)

    def module_run(self, arg, backend=False, mode='verify'):
        """
        运行已选择的模块

        :param arg: 运行参数
        :param backend: 是否后台运行
        :param mode: 运行模式
        :return:
        """
        self.setMode(mode)
        if arg:
            # 验证参数合法性 防止argparse解析时候报错退出console
            options = [option_key.replace("--", "") for option_key in arg.split() if option_key.startswith("--")]
            require_options = self.currentModule.get_requireOpts()
            for option in require_options:
                if option not in options:
                    console.error("模块缺少必要参数 [bold green]{0}[/bold green]. 请使用[bold cyan]-P[/bold cyan]"
                                  "或者[bold cyan]--options[/bold cyan]选项提供.".format(option))
                    return

            all_options = self.currentModule.get_allOpts()
            for option in options:
                if option not in all_options:
                    console.error("无法识别的模块参数: [bold green]{0}[/bold green]".format(option))
                    return
            setattr(env.CliOptions, 'options', arg)
        if backend:
            # 新线程中运行模块
            try:
                _thread.start_new_thread(self.thread_run, ())
            except Exception as e:
                console.error("后台运行模块失败: {0}".format(e.args[0]))
            sleep(0.5)
        else:
            self.process_run()

    def thread_run(self, *args, **kwargs):
        """
        新线程运行

        :param args:
        :param kwargs:
        :return:
        """
        self.process_run()

    def process_run(self):
        """
        执行已选择的模块并输出结果

        :return:
        """
        result = ModuleLoader.run_loaded_module(self.currentModule, env.CliOptions)
        if result.is_success():
            console.success(result.message, result.data if result.data else "")
        else:
            console.failed(result.message, result.data if result.data else "")

    def setMode(self, mode):
        """
        设置模块运行模式

        :param mode: 模块运行模式
        :return:
        """
        if mode.lower() == "exploit":
            self.setExploitMode()
        if mode.lower() == "verify":
            self.setVerifyMode()

    @staticmethod
    def setExploitMode():
        try:
            setattr(env.CliOptions, "exploit", True)
            setattr(env.CliOptions, "verify", False)
        except Exception as e:
            console.warning("设置exploit模式错误: {0}".format(e.args[0]))

    @staticmethod
    def setVerifyMode():
        try:
            setattr(env.CliOptions, "exploit", False)
            setattr(env.CliOptions, "verify", True)
        except Exception as e:
            console.warning("设置verify模式错误: {0}".format(e.args[0]))

    @silentConsole
    def do_exploit(self, arg):
        self.module_run(arg, mode="exploit")

    @silentConsole
    def do_verify(self, arg):
        self.module_run(arg, mode="verify")

    @silentConsole
    def do_scfinit(self, arg):
        processScf("init")

    @silentConsole
    def do_scfcls(self, arg):
        processScf("clear")

    @silentConsole
    def do_scfrst(self, arg):
        processScf("reset")

    def do_reload(self, arg):
        import importlib
        module = importlib.import_module(consoleShell.__module__)
        importlib.reload(module)
        newObj = consoleShell()
        self.__class__ = newObj.__class__
        self.__dict__ = newObj.__dict__

    @staticmethod
    def help_use():
        console.print("[green]选择运行的模块:\n\t usage: use modulePath[/green]")

    @staticmethod
    def help_info():
        console.print("[green]查看已选模块或指定模块详细信息:\n\t usage: info \[alias] \[modulePath] [/green]")

    @staticmethod
    def help_setg():
        console.print("[green]设置全局参数值:\n\t usage: setg option optionValue[/green]")

    @staticmethod
    def help_set():
        console.print("[green]设置模块参数值:\n\t usage: set option optionValue[/green]")

    @staticmethod
    def help_get():
        console.print("[green]获取全局参数或模块参数当前值\n\t usage: get optName[/green]")

    @staticmethod
    def help_show():
        console.print("[green]显示给定类型的模块信息或者全部模块:\n\t usage: show type[/green]")

    @staticmethod
    def help_run():
        console.print("[green]执行已选定的模块(以verify模式):\n\t usage: run options"
                      "\n\t--optName optValue 为模块的optName参数设置optValue值"
                      "\n\t-b 将模块放置后台运行[/green]")

    @staticmethod
    def help_exploit():
        console.print("[green]以exploit模式执行已选定的模块:\n\t usage: exploit options[/green]")

    @staticmethod
    def help_verify():
        console.print("[green]以verify模式执行已选定的模块:\n\t usage: verify options[/green]")

    def help_md5(self):
        self.help_encrypt("md5")

    def help_base64(self):
        self.help_encrypt("base64")

    def help_mmh3(self):
        self.help_encrypt("mmh3")

    def help_hex(self):
        self.help_encrypt("hex")

    def help_unhex(self):
        self.help_encrypt("unhex")

    def help_encrypt(self, method):
        console.print("[green]常用加解密功能命令: [bold yellow]{0}[/bold yellow] , 提供URL将请求URL内容进行编码\n\t"
                      " usage: {1} [-d] \[cipherText]\n\t -d\t\t解密选项\n\t cipherText\t需要加解密内容,"
                      " 支持使用url:URL格式请求URL内容进行加解密".format(method, method))

    @staticmethod
    def help_reload():
        console.print("[green]重载并应用consoleShell模块的代码更改[/green]")

    def default(self, line):
        """
        重载 default 用于输出无法识别的命令

        :param line: 输入的命令
        :return:
        """
        console.print("[yellow]无效的命令: [bold green]%s[/bold green],"
                      " 输入[bold green]help[/bold green] 或 [bold green]?[/bold green] 获取命令帮助[/yellow]\n" % line)

    def completedefault(self, text, line, begidx, endidx):
        allCommands = []
        for group in self.commands:
            allCommands.append(self.commands[group].keys)
        return allCommands

    def emptyline(self):
        """
        重载 emptyline 解决空行调用上一命令问题

        :return:
        """
        return

    def cmdloop(self, intro=None):
        """
        重载 cmdloop 改用rich.prompt

        :param intro:
        :return:
        """
        self.preloop()
        if self.use_rawinput and self.completekey:
            try:
                import readline
                self.old_completer = readline.get_completer()
                readline.set_completer(self.complete)
                readline.parse_and_bind(self.completekey + ": complete")
            except ImportError:
                pass
        try:
            if intro is not None:
                self.intro = intro
            if self.intro:
                # self.stdout.write(str(self.intro) + "\n")
                console.print(self.intro)
            stop = None
            while not stop:
                if self.cmdqueue:
                    line = self.cmdqueue.pop(0)
                else:
                    if self.use_rawinput:
                        try:
                            # 改用 ExpPrompt.ask
                            line = ExpPrompt.ask(self.prompt)
                        except EOFError:
                            line = 'EOF'
                    else:
                        self.stdout.write(self.prompt)
                        self.stdout.flush()
                        line = self.stdin.readline()
                        if not len(line):
                            line = 'EOF'
                        else:
                            line = line.rstrip('\r\n')
                try:
                    # 再循环内捕获异常 防止发生异常后退出交互式shell
                    line = self.precmd(line)
                    stop = self.onecmd(line)
                    stop = self.postcmd(stop, line)
                except Exception as e:
                    console.exception(e.args[0])
            self.postloop()
        finally:
            if self.use_rawinput and self.completekey:
                try:
                    import readline
                    readline.set_completer(self.old_completer)
                except ImportError:
                    pass

    @silentConsole
    def do_help(self, arg):
        """
        List available commands with "help" or detailed help with "help cmd".
        """
        if arg:
            # XXX check arg syntax
            try:
                func = getattr(self, 'help_' + arg)
            except AttributeError:
                try:
                    doc = getattr(self, 'do_' + arg).__doc__
                    if doc:
                        console.print("[green]%s[/green]\n" % str(doc))
                        return
                except AttributeError:
                    pass
                console.print("%s\n" % str(self.nohelp % (arg,)))
                return
            func()
        else:
            self.print_help()

    def preloop(self):
        """
        启动前加载命令参数提供的模块信息

        :return:
        """
        # 自动选择并使用命令行提供的模块
        module_info = None
        if env.CliOptions.module:
            module_info = self.getModuleInfoByArg(env.CliOptions.module.replace("\\", "/"))
        if module_info:
            self.do_use(module_info["path"])
        # 设置模块参数
        if env.CliOptions.options and self.currentModule:
            options = cli2args(env.CliOptions.options.split())
            allOpts = self.currentModule.get_allOpts()
            for option in options:
                if option.startswith("--"):
                    optValue = options[options.index(option) + 1]
                    option = option.replace("--", "")
                    if option in allOpts:
                        self.currentModule.set_option(option, optValue)
        # 设置host参数
        if env.CliOptions.host and self.currentModule:
            self.currentModule.add_host(env.CliOptions.host)

        self.postcmd(False, "")

    def postcmd(self, stop, line):
        """
        显示实时选择的模块

        :param stop:
        :param line:
        :return:
        """
        if self.currentModule:
            self.prompt = '[bold red3]ExpDepos([royal_blue1]{0}[/royal_blue1])>[bold red3]' \
                .format(self.currentModule.SPEC.replace("modules.", "").replace(".", "/"))
        return stop

    def print_help(self):
        """
        格式化打印帮助信息

        :return:
        """
        for group in self.commands:
            print_doc_header(group)
            print_doc_header("Command", "Description", dash="-", style="deep_sky_blue4", prefix="\t")
            for command, description in self.commands[group].items():
                console.print("\t[bold yellow]" + command + "[/bold yellow]\t\t\t\t" + "[cyan]"
                              + description + "[/cyan]")
            console.print("")

    def do_test(self, ignore):
        allCommands = []
        for group in self.commands:
            console.print(self.commands[group].keys)

    @staticmethod
    def do_exit(ignore):
        """退出 ExpDepos"""
        return True

    @staticmethod
    def loadModule(module_info):
        console.debug("正在加载模块： [royal_blue1]{0}[/royal_blue1]".format(module_info["path"]))
        modulePath = format_module_path(module_info["path"])
        return ModuleLoader.load_module_from_file(modulePath)
