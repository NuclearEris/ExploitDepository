#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/10/18 11:21
"""
import os
import sys
import cmd
import mmh3
import base64
import codecs
import hashlib
import _thread
from time import sleep
import ExpDepos.libs.core.Request as Request
from ExpDepos.libs.core.base.ModuleBase import ModuleBase
from ExpDepos.libs.core.base.OptionsBase import Option

try:
    import ExpDepos
except ImportError:
    sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))

from ExpDepos.libs.core.common.Common import *
from ExpDepos.libs.core.ModuleLoader import ModuleLoader
from ExpDepos.libs.core.common.ExpPrompt import ExpPrompt


def parse(arg):
    return tuple(arg.split())


def parseValue(value: str):
    if value.isnumeric():
        return int(value)
    if value.lower() == "false":
        return False
    if value.lower() == "true":
        return True
    return value


def get_list(offs, short_list, current_mark):
    lists = []
    for item in short_list:
        if len(item) < offs:  # 忽略掉长度小于offs值的条目，防止后续取值报错
            continue
        if (item.isupper() or item[offs:][0].isupper()) and current_mark and current_mark[-1].islower():  # 兼容小写输入
            current_mark = current_mark.upper()
        if item.startswith(current_mark) or item.upper().startswith(current_mark):
            lists.append(item[offs:])
    return lists


def complete_process(text, line, begidx, endidx, shortList):
    if text or line:
        currentMakeup = line[line.rindex(" ") + 1:]
        offs = len(currentMakeup) - len(text)
        # 当候选列表中的值为大写且输入值为小写时候自动将输入值转换为大写 反之亦然
        lists = get_list(offs, shortList, currentMakeup)
        return lists
    else:
        return shortList


def format_module_path(module_info_path):
    modulePath = "modules" + os.sep + module_info_path
    return modulePath.replace("/", os.sep)


def print_doc_header(*args, style="cyan", dash="=", tab_gap_len=4, prefix=""):
    """
    打印命令行格式化文档输出标题

    :param args: 格式化文档内容
    :param style: 颜色样式 默认cyan
    :param dash: 下划线字符 默认“=”
    :param tab_gap_len: 制表符间隔长度 默认4
    :param prefix: 前缀内容
    :return:
    """
    if dash:
        console.print("")
    console.print("[{style}]".format(style=style) + prefix +
                  ("\t" * tab_gap_len).join(args) +
                  "[/{style}]".format(style=style))
    if dash:
        dash_args = tuple(dash * len(doc) for doc in args)
        # 打印下划线的时候置空dash 以此做判断依据 防止死循环
        print_doc_header(*dash_args, dash="", style=style, tab_gap_len=tab_gap_len, prefix=prefix)


def silentConsole(method):
    """
    实现Console默认无debug信息输出的装饰器

    :param method: 被装饰的do_command函数
    :return:
    """

    @wraps(method)
    def wrapper(self, *args, **kwargs):
        tmpMsgLevel = console.getMsgLevel()
        debugLevel = console.levels.get("DEBUG")["level"]
        # 只有在用户未主动设置debug模式且当前消息等级大于等于debug等级才更改
        if not self.debug and tmpMsgLevel >= debugLevel:
            console.setMsgLeve(debugLevel - 1)
        method(self, *args, **kwargs)
        console.setMsgLeve(tmpMsgLevel)

    return wrapper


def processScf(action="init"):
    if not env.Config.CloudFunctions:
        console.error("未找到云函数相关配置信息, 请在config中配置.")
        return
    if action == "init":
        scfInit(env.Config.CloudFunctions)
    if action == "clear":
        scfclear(env.Config.CloudFunctions)
    if action == "reset":
        if scfclear(env.Config.CloudFunctions):
            scfInit(env.Config.CloudFunctions)


def getObjAndOpts(module, reload=False):
    """
    从已加载的模块中获取模块对象及所有参数信息

    :param module: 模块标识，可选Alias或是模块路径
    :param reload: 是否重新加载模块
    :return:
    """
    obj = None
    obj_option_list = []
    obj_info = ModuleLoader.get_loaded_module(module, reload=reload)
    if obj_info:
        obj = obj_info["module"]
        obj_option_list = obj.get_allOpts()
    return obj, obj_option_list


def key_is_in_module(key, module):
    """
    检查key是否属于模块自定义参数

    """
    if not isinstance(module, ModuleBase):
        return False
    return key in module.OPTIONS


def set_module_options(module, cli_opts, module_opts):
    """
    设置模块参数

    """
    for option in cli_opts:
        if option.startswith("--"):
            opt_value = cli_opts[cli_opts.index(option) + 1]
            option = option.replace("--", "")
            if option in module_opts:
                module.set_option(option, opt_value)


class consoleShell(cmd.Cmd):
    intro = '[green]Welcome to the ExpDepos shell.' \
            ' Type [bold yellow]help[/bold yellow] or [bold yellow]?[/bold yellow] to list commands.\n[green]'
    prompt = '[bold magenta]ExpDepos>[/bold magenta]'
    nohelp = "[yellow]没有命令: [/yellow][bold green]%s[/bold green] [yellow]的帮助信息[/yellow]"

    def __init__(self):
        super().__init__()
        self.request = Request.instance(env.CliOptions)
        self.modules = env.modules
        self.currentModule = None
        self.currentMsgLevel = None
        self.debug = False
        self.globalOpt = ['verbose', 'host', 'useScf', 'auth', 'cookie', 'headers', 'agent',
                          'referer', 'timeout', 'retries', 'rdelay', 'delay', 'proxy', 'thread']
        self.commands = {"Core Commands": {'?': '打印命令帮助',
                                           'help': '等同 ? 命令',
                                           'setg': '设置全局参数值',
                                           'get': '获取参数值',
                                           'show': '显示给定类型的模块信息或者全部模块',
                                           'debug': '设置Console输出为Debug模式',
                                           'undebug': '设置Console输出为非Debug模式',
                                           'exit': '退出Console'},
                         "Module Commands": {'use': '通过模块别名或路径选择使用的模块',
                                             'set': '设置模块参数值',
                                             'run': '执行已选中的模块(默认verify模式)',
                                             'exploit': '以exploit模式运行模块',
                                             'verify': '以verify模式运行模块',
                                             'info': '显示模块详细信息'},
                         "Cloud Functions": {
                             'scfinit': '初始化云函数',
                             'scfcls': '删除全部云函数',
                             'scfrst': '重置云函数'},
                         "Tools Functions": {
                             'md5': 'md5加密工具',
                             'base64': 'base64加密',
                             'mmh3': 'mmh3加密',
                             'hex': 'hex编码',
                             'unhex': 'hex解码',
                             'add': '添加字典或者指纹'
                         },
                         "Debug Commands": {
                             'reload': '重载并应用consoleShell模块的代码更改'}
                         }
        self.subCmd_show = ['info', 'modules', 'exploits', 'payloads', 'encoders', 'alias', 'options', "fps"]
        self.subcmd_add = ['fps', 'dir', 'file']
        self.dic_path = env.Config.DATA_PATH + os.sep + "dics" + os.sep + "superscan" + os.sep
        self.module_info = None

    def getModuleFiles(self, filters=None) -> list:
        """
        获取所有模块路径

        :return: list
        """
        if filters is None:
            filters = ['exploit', 'payload', 'encoder']
        return [module["path"] for module in self.modules if module["Type"] in filters]

    def getModuleAlias(self) -> list:
        """
        获取所有模块别名

        :return: list
        """
        return [module["Alias"] for module in self.modules]

    def getModuleInfoByArg(self, arg) -> dict:
        """
        根据 arg 值匹配路径或者别名的模块

        :param arg: 关键字
        :return: dict 已加载的模块信息
        """
        for module in self.modules:
            if module["path"] == arg or module["path"] in arg or module['Alias'] == arg:
                return module

    @silentConsole
    def do_use(self, arg):
        if arg in self.getModuleFiles(filters=["exploit"]) or arg in self.getModuleAlias():
            module_info = self.getModuleInfoByArg(arg)
            if module_info["isLoad"]:
                self.currentModule = module_info["module"]
            else:
                self.currentModule = self.loadModule(module_info)
        else:
            console.warning("无法使用模块 [royal_blue1]{0}[/royal_blue1], 请确认模块路径是否正确.".format(arg))

    def complete_use(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.getModuleFiles(filters=["exploit"]))

    @silentConsole
    def do_info(self, arg):
        module = None
        if arg:
            if arg in self.getModuleFiles() or arg in self.getModuleAlias():
                module_info = self.getModuleInfoByArg(arg)
                if module_info["isLoad"]:
                    module = module_info["module"]
                else:
                    module = self.loadModule(module_info)
            else:
                console.warning("无法查看模块 [royal_blue1]{0}[/royal_blue1] 信息, 请确认模块路径是否正确.".format(arg))
        else:
            if self.currentModule:
                module = self.currentModule
            else:
                console.warning("请选择需要查看的模块或使用 [bold green]help info[/bold green] 查看命令帮助.")
        if module:
            ModuleLoader.show_module_info(module)

    def complete_info(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.getModuleFiles())

    @silentConsole
    def do_set(self, arg):
        args = parse(arg)
        if len(args) >= 1:
            if self.currentModule:
                option_list = self.currentModule.get_allOpts()
                # 设置payload 和encoder参数
                payload_option_list = []
                encoder_option_list = []
                payload_obj = None
                encoder_obj = None
                payload = self.currentModule.get_option("payload", '')
                if payload:
                    payload_obj, payload_option_list = getObjAndOpts(payload)
                    if payload_obj:
                        encoder = payload_obj.get_option("encoder")
                        if encoder:
                            encoder_obj, encoder_option_list = getObjAndOpts(encoder)
                if args[0].lower() in option_list \
                        or args[0].lower() in payload_option_list \
                        or args[0].lower() in encoder_option_list:
                    if len(args) >= 2:
                        if args[0].lower() in payload_option_list and payload_obj:
                            module = payload_obj
                        elif args[0].lower() in encoder_option_list and encoder_obj:
                            module = encoder_obj
                        else:
                            module = self.currentModule
                        module.set_option(args[0].lower(), " ".join(args[1:]))
                        # 更新 env.CliOptions 值
                        if args[0].lower() in env.CliOptions:
                            setattr(env.CliOptions, args[0].lower(), parseValue(" ".join(args[1:])))
                        console.print(args[0] + " ==> " + " ".join(args[1:]))
                    else:
                        console.print("[yellow]set 命令错误 请提供参数值[/yellow]")
                elif args[0].lower() in self.globalOpt:
                    self.do_setg(arg)
                else:
                    console.print("[yellow]不存在的模块参数: {0}[/yellow]".format(args[0]))
            else:
                self.do_setg(arg)
        else:
            self.do_help("set")

    def complete_set(self, text, line, begidx, endidx):
        ext_list = []  # 扩展列表 用于存储payload和encoder参数
        if self.currentModule:
            copy_line = line.split()
            mark = copy_line[-1]  # 验证最后输入内容是否为Option类型
            current_mark, module_obj = self.isOptObj(mark)
            if (not current_mark or not module_obj) and len(copy_line) >= 2:  # 验证最后输入前一位是否为Option类型
                current_mark, module_obj = self.isOptObj(copy_line[len(copy_line) - 2 if len(copy_line) > 2 else 1])
                mark = copy_line[len(copy_line) - 2 if len(copy_line) > 2 else 1]
            # 如果是Payload或者Encoder类型则候选列表为payload或者encoder模块
            if " PAYLOAD" in line.upper() or current_mark == 'Payload':
                option_list = self.getModuleFiles(filters=["payload"])
            elif " ENCODER" in line.upper() or current_mark == 'Encoder':
                option_list = self.getModuleFiles(filters=["encoder"])
            elif current_mark and module_obj:
                # 如果是Option类型且有候选列表(choices)则使用该列表
                if module_obj.OPTIONS[mark.lower()].choices:
                    option_list = module_obj.OPTIONS[mark.lower()].choices
            else:
                option_list = [key.upper() for key in self.currentModule.get_allOpts()]
            # 最后输入为非Option类型时候获取payload和encoder参数
            payload = self.currentModule.get_option("payload", '')
            if payload and (" PAYLOAD" not in line.upper()
                            and " ENCODER" not in line.upper()
                            and module_obj is None):
                payload_obj, payload_option_list = getObjAndOpts(payload)
                ext_list.extend(payload_option_list)
                if payload_obj:
                    encoder = payload_obj.get_option("encoder")
                    if encoder:
                        encoder_obj, encoder_option_list = getObjAndOpts(encoder)
                        ext_list.extend(encoder_option_list)
        else:
            option_list = [key.upper() for key in self.globalOpt]
        option_list.extend([key.upper() for key in ext_list])
        return complete_process(text, line, begidx, endidx, option_list)

    @silentConsole
    def do_get(self, arg):
        value = None
        if arg == "USESCF":
            optName = "useScf"
        else:
            optName = arg.lower()
        try:
            if optName in self.globalOpt:
                value = getattr(env.CliOptions, optName)
            if self.currentModule and optName in self.currentModule.get_allOpts():
                value = self.currentModule.get_option(optName)
        except Exception as e:
            console.warning("无法获取参数值: {0}".format(e.args[0]))
        console.print(arg + " ==> " + str(value))

    def complete_get(self, text, line, begidx, endidx):
        short_list = self.globalOpt
        if self.currentModule:
            allOpts = self.currentModule.get_allOpts()
            short_list.extend(allOpts)
        return complete_process(text, line, begidx, endidx, [key.upper() for key in short_list])

    @silentConsole
    def do_setg(self, arg):
        arg = parse(arg)
        if len(arg) >= 1:
            if arg[0] == "USESCF":
                optName = "useScf"
            else:
                optName = arg[0].lower()
            if optName in self.globalOpt:
                if len(arg) >= 2:
                    setattr(env.CliOptions, optName, parseValue(" ".join(arg[1:])))
                    if optName == "verbose":
                        console.setMsgLeve(parseValue(arg[1]))
                        console.setLogLevel(parseValue(arg[1]))
                    if optName == "host" and self.currentModule:
                        self.currentModule.add_host(arg[1])
                    console.print("{0} ==> {1}".format(arg[0], " ".join(arg[1:])))
                else:
                    console.print("[yellow]setg 命令错误 请提供参数值[/yellow]")
            else:
                console.print("[yellow]不存在的全局参数: [/yellow][bold green] %s [/bold green]" % arg[0])
        else:
            self.do_help("setg")

    def complete_setg(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, [key.upper() for key in self.globalOpt])

    @silentConsole
    def do_show(self, arg):
        if arg in self.subCmd_show:
            subShowFunc = getattr(self, 'show_' + arg)
            subShowFunc()
        else:
            console.print("[yellow]无效的命令参数：[bold green]{0}[/bold green][/yellow]".format(arg))

    def show_info(self):
        self.do_info('')

    def show_modules(self):
        print_doc_header("List All Modules")
        ModuleLoader.list_modules("modules", self.modules)

    def show_exploits(self):
        print_doc_header("List All Exploits")
        ModuleLoader.list_modules("modules", self.modules, filters=["exploit"])

    def show_payloads(self):
        print_doc_header("List All Payloads")
        ModuleLoader.list_modules("modules", self.modules, filters=["payload"])

    def show_encoders(self):
        print_doc_header("List All Encoders")
        ModuleLoader.list_modules("modules", self.modules, filters=["encoder"])

    def show_alias(self):
        print_doc_header("List All Aliases")
        ModuleLoader.list_modules("alias", self.modules)

    def show_fps(self):
        print_doc_header("List All fingerprints")
        ModuleLoader.list_modules("fps", env.fps)

    def show_options(self):
        if self.currentModule:
            module_info = ModuleLoader.get_module_info(self.currentModule)
            options_info = module_info.pop("options_info")
            print_doc_header("List Module Options")
            ModuleLoader.show_options(self.currentModule, options_info)
            payload = self.currentModule.get_option("payload", '')
            # 显示payload参数
            if payload:
                payload_info = ModuleLoader.get_loaded_module(payload)
                if payload_info:
                    payload_obj = payload_info["module"]
                    payload_obj_info = ModuleLoader.get_module_info(payload_obj)
                    payload_options_info = payload_obj_info.pop("options_info")
                    print_doc_header("List Payload Options")
                    ModuleLoader.show_options(payload_obj, payload_options_info)
                    # 显示encoder参数
                    encoder = payload_obj.get_option("encoder")
                    if encoder:
                        encoder_info = ModuleLoader.get_loaded_module(encoder)
                        if encoder_info:
                            encoder_obj = encoder_info["module"]
                            encoder_obj_info = ModuleLoader.get_module_info(encoder_obj)
                            encoder_options_info = encoder_obj_info.pop("options_info")
                            print_doc_header("List Encoder Options")
                            ModuleLoader.show_options(encoder_obj, encoder_options_info)
        else:
            console.print("[yellow]当前无已选模块, 请先选择使用模块.[/yellow]")

    def complete_show(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.subCmd_show)

    def do_md5(self, arg):
        self.encrypt('md5', arg)

    def do_base64(self, arg):
        self.encrypt('base64', arg)

    def do_mmh3(self, arg):
        self.encrypt('mmh3', arg)

    def do_hex(self, arg):
        self.encrypt('hex', arg)

    def do_unhex(self, arg):
        self.encrypt("unhex", arg)

    def encrypt(self, method, arg):
        args = cli2args(arg.split())
        decrypt = False
        if "-d" in args:
            args = args[args.index("-d") + 1:]
            decrypt = True
        arg_str = "".join(args)
        if "url" in arg_str:
            url = arg_str[arg_str.index(":") + 1:]
            response = self.request.get(url)
            content = response.content
        else:
            content = bytes(arg_str.encode("UTF-8"))
        if method == "md5":
            console.print("md5: " + hashlib.md5(content).hexdigest())
        if method == "base64":
            if not decrypt:
                console.print("base64: " + base64.b64encode(content).decode())
            else:
                console.print("base64: " + base64.b64decode(content).decode())
        if method == "mmh3":
            console.print("mmh3: {0}".format(mmh3.hash(codecs.lookup('base64').encode(content)[0])))
        if method == "hex":
            if not decrypt:
                console.print("hex: 0x" + "".join([hexStr[2:] for hexStr in [hex(x) for x in content]]))
            else:
                content = content.decode("utf-8")
                if content.startswith("0x"):
                    content = content[2:]
                console.print("".join([chr(int(hexStr, 16)) for hexStr in
                                       [''.join(content[i:i + 2]) for i in range(0, len(content), 2)]]))
        if method == "unhex":
            content = content.decode("utf-8")
            if content.startswith("0x"):
                content = content[2:]
            console.print("".join([chr(int(hexStr, 16)) for hexStr in
                                   [''.join(content[i:i + 2]) for i in range(0, len(content), 2)]]))

    def do_add(self, arg):
        if not arg:
            self.help_add()
            return
        args = cli2args(arg.split())
        try:
            action, value = args
        except Exception as e:
            action = args[0]
            value = ''

        if action == "dir":
            self._add_dic(action, value)
        if action == "file":
            self._add_dic(action, value)
        if action == "fps":
            self._add_fps()

    def _add_dic(self, action, dic_value):
        if not dic_value:
            console.error("需要添加的字典值不能为空!")
            return
        if "," in dic_value:
            dic_value = dic_value.split(",")
        if isinstance(dic_value, str):
            dic_value = [dic_value]
        dirs = self._load_dic(action)
        append = []
        for value in dic_value:
            if not value.startswith("/"):
                value = "/" + value
            value = value.strip()
            value = value.replace("//", "/")
            if value in dirs:
                console.warning(f"[bold green]{action}[/bold green] 字典中已存在: [bold yellow]{value}[/bold yellow]")
                continue
            dirs.append(value)
            append.append(value)
        if append:
            try:
                self._save_dic(action, dirs)
                console.info(f"已添加 [bold yellow]{append}[/bold yellow] 到字典"
                             f" [bold green]{action}[/bold green], 共 {len(append)} 条")
            except Exception as e:
                console.error(f"[bold green]{action}[/bold green] 字典添加失败: {repr(e)}")

    def _load_dic(self, file):
        dics = []
        file_name = "dirs.dic"
        if file == "dir":
            file_name = "dirs.dic"
        if file == "file":
            file_name = "files.dic"
        dic_path = self.dic_path + file_name
        if not os.path.exists(dic_path):
            console.error(f"找不到字典文件: {dic_path}")
            return
        for line in open(dic_path, encoding=get_encoding(dic_path)):
            if not line.startswith("/"):
                line = "/" + line
            line = line.strip()
            line = line.replace("//", "/")
            dics.append(line)
        return dics

    def _save_dic(self, action, dirs):
        file_name = "dirs.dic"
        if action == "dir":
            file_name = "dirs.dic"
        if action == "file":
            file_name = "files.dic"
        dic_path = self.dic_path + file_name
        dic_data = "\n".join(dirs)
        with open(dic_path, encoding=get_encoding(dic_path), mode="w") as dic_file:
            return dic_file.write(dic_data)

    def _add_fps(self):
        self.do_use("addfps")
        self.do_exploit("")

    def complete_add(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.subcmd_add)

    @silentConsole
    def do_debug(self, arg):
        """设置Console输出为Debug模式"""
        self.currentMsgLevel = console.getMsgLevel()
        debugLevel = console.levels.get("DEBUG")["level"]
        self.do_setg(arg="verbose {0}".format(debugLevel))
        self.debug = True

    @silentConsole
    def do_undebug(self, arg):
        """解除Console的Debug模式"""
        debugLevel = console.levels.get("DEBUG")["level"]
        if console.getMsgLevel() >= debugLevel:
            if self.currentMsgLevel and self.currentMsgLevel < debugLevel:
                msgLevel = self.currentMsgLevel
            else:
                msgLevel = debugLevel - 1
            self.do_setg(arg="verbose " + str(msgLevel))
            self.debug = False

    @silentConsole
    def do_run(self, arg: str):
        mode = "verify"
        backend = False
        args = cli2args(arg.split())
        if "-b" in args:
            backend = True
        if "--mode" in args:
            mode = args[args.index("--mode") + 1]
        allOpts = self.currentModule.get_allOpts()
        # 根据模块所有自定义参数遍历arg中的参数并重组成字符串
        arg = " ".join(["--" + option + " " + add_quote(args[args.index("--" + option) + 1])
                        for option in allOpts if "--" + option in args])
        self.module_run(arg, backend=backend, mode=mode)

    def module_run(self, arg, backend=False, mode='verify'):
        """
        运行已选择的模块

        :param arg: 运行参数
        :param backend: 是否后台运行
        :param mode: 运行模式
        :return:
        """
        self.setMode(mode)
        require_options = self.currentModule.get_requireOpts()
        if require_options and not arg:
            console.error("[green]{0}[/green] 模块缺少必要参数: {1}".format(self.currentModule.Name, require_options))
            return
        if arg:
            # 验证参数合法性 防止argparse解析时候报错退出console
            options = [option_key.replace("--", "") for option_key in arg.split() if option_key.startswith("--")]
            for option in require_options:
                if option not in options:
                    console.error("模块缺少必要参数 [bold green]{0}[/bold green]. 请使用[bold cyan]-P[/bold cyan]"
                                  "或者[bold cyan]--options[/bold cyan]选项提供.".format(option))
                    return

            all_options = self.currentModule.get_allOpts()
            for option in options:
                if option not in all_options:
                    console.error("无法识别的模块参数: [bold green]{0}[/bold green]".format(option))
                    return
            setattr(env.CliOptions, 'options', arg)
        if backend:
            # 新线程中运行模块
            try:
                _thread.start_new_thread(self.thread_run, ())
            except Exception as e:
                console.error("后台运行模块失败: {0}".format(e.args[0]))
            sleep(0.5)
        else:
            self.process_run()

    def thread_run(self, *args, **kwargs):
        """
        新线程运行

        :param args:
        :param kwargs:
        :return:
        """
        self.process_run()

    def process_run(self):
        """
        执行已选择的模块并输出结果

        :return:
        """
        result = ModuleLoader.run_loaded_module(self.currentModule, env.CliOptions)
        if result.is_success():
            console.success(result.message, result.data if result.data else "")
        else:
            console.failed(result.message, result.data if result.data else "")

    def setMode(self, mode):
        """
        设置模块运行模式

        :param mode: 模块运行模式
        :return:
        """
        if mode.lower() == "exploit":
            self.setExploitMode()
        if mode.lower() == "verify":
            self.setVerifyMode()

    @staticmethod
    def setExploitMode():
        try:
            setattr(env.CliOptions, "exploit", True)
            setattr(env.CliOptions, "verify", False)
        except Exception as e:
            console.warning("设置exploit模式错误: {0}".format(e.args[0]))

    @staticmethod
    def setVerifyMode():
        try:
            setattr(env.CliOptions, "exploit", False)
            setattr(env.CliOptions, "verify", True)
        except Exception as e:
            console.warning("设置verify模式错误: {0}".format(e.args[0]))

    @silentConsole
    def do_exploit(self, arg):
        self.module_run(arg, mode="exploit")

    @silentConsole
    def do_verify(self, arg):
        self.module_run(arg, mode="verify")

    @silentConsole
    def do_scfinit(self, arg):
        processScf("init")

    @silentConsole
    def do_scfcls(self, arg):
        processScf("clear")

    @silentConsole
    def do_scfrst(self, arg):
        processScf("reset")

    @silentConsole
    def do_NULL(self, arg):
        console.print("")

    def do_reload(self, arg):
        import importlib
        module = importlib.import_module(consoleShell.__module__)
        importlib.reload(module)
        newObj = consoleShell()
        self.__class__ = newObj.__class__
        self.__dict__ = newObj.__dict__

    @staticmethod
    def help_use():
        console.print("[green]选择运行的模块:\n\t usage: use modulePath[/green]")

    @staticmethod
    def help_info():
        console.print("[green]查看已选模块或指定模块详细信息:\n\t usage: info \[alias] \[modulePath] [/green]")

    @staticmethod
    def help_setg():
        console.print("[green]设置全局参数值:\n\t usage: setg option optionValue[/green]")

    @staticmethod
    def help_set():
        console.print("[green]设置模块参数值:\n\t usage: set option optionValue[/green]")

    @staticmethod
    def help_get():
        console.print("[green]获取全局参数或模块参数当前值\n\t usage: get optName[/green]")

    @staticmethod
    def help_show():
        console.print("[green]显示给定类型的模块信息或者全部模块:\n\t usage: show type[/green]")

    @staticmethod
    def help_add():
        console.print("[green]添加字典或者指纹:\n\t usage: add \[option]"
                      "\n\t dir\t添加目录字典 多个使用 ',' 分隔"
                      "\n\t file\t添加文件字典 [bold yellow]$VAR$[/bold yellow] 可作为扩展名变量 多个使用 ',' 分隔"
                      "\n\t fps\t运行指纹添加向导模块[/green]")

    @staticmethod
    def help_run():
        console.print("[green]执行已选定的模块(以verify模式):\n\t usage: run options"
                      "\n\t--optName optValue 为模块的optName参数设置optValue值"
                      "\n\t--mode 运行模式(可选verify或是exploit)"
                      "\n\t-b 将模块放置后台运行[/green]")

    @staticmethod
    def help_exploit():
        console.print("[green]以exploit模式执行已选定的模块:\n\t usage: exploit options[/green]")

    @staticmethod
    def help_verify():
        console.print("[green]以verify模式执行已选定的模块:\n\t usage: verify options[/green]")

    def help_md5(self):
        self.help_encrypt("md5")

    def help_base64(self):
        self.help_encrypt("base64")

    def help_mmh3(self):
        self.help_encrypt("mmh3")

    def help_hex(self):
        self.help_encrypt("hex")

    def help_unhex(self):
        self.help_encrypt("unhex")

    def help_encrypt(self, method):
        console.print("[green]常用加解密功能命令: [bold yellow]{0}[/bold yellow] , 提供URL将请求URL内容进行编码\n\t"
                      " usage: {1} [-d] \[cipherText]\n\t -d\t\t解密选项\n\t cipherText\t需要加解密内容,"
                      " 支持使用url:URL格式请求URL内容进行加解密".format(method, method))

    @staticmethod
    def help_reload():
        console.print("[green]重载并应用consoleShell模块的代码更改[/green]")

    def default(self, line):
        """
        重载 default 用于输出无法识别的命令

        :param line: 输入的命令
        :return:
        """
        console.print("[yellow]无效的命令: [bold green]%s[/bold green],"
                      " 输入[bold green]help[/bold green] 或 [bold green]?[/bold green] 获取命令帮助[/yellow]\n" % line)

    def completedefault(self, text, line, begidx, endidx):
        allCommands = []
        for group in self.commands:
            allCommands.append(self.commands[group].keys)
        return allCommands

    def emptyline(self):
        """
        重载 emptyline 解决空行调用上一命令问题

        :return:
        """
        return

    def cmdloop(self, intro=None):
        """
        重载 cmdloop 改用rich.prompt

        :param intro:
        :return:
        """
        self.preloop()
        if self.use_rawinput and self.completekey:
            try:
                import readline
                self.old_completer = readline.get_completer()
                readline.set_completer(self.complete)
                readline.parse_and_bind(self.completekey + ": complete")
            except ImportError:
                pass
        try:
            if intro is not None:
                self.intro = intro
            if self.intro:
                # self.stdout.write(str(self.intro) + "\n")
                console.print(self.intro)
            stop = None
            while not stop:
                if self.cmdqueue:
                    line = self.cmdqueue.pop(0)
                else:
                    if self.use_rawinput:
                        try:
                            # 改用 ExpPrompt.ask
                            line = ExpPrompt.ask(self.prompt)
                        except KeyboardInterrupt:
                            line = 'NULL'
                        except EOFError:
                            line = 'EOF'
                    else:
                        self.stdout.write(self.prompt)
                        self.stdout.flush()
                        line = self.stdin.readline()
                        if not len(line):
                            line = 'EOF'
                        else:
                            line = line.rstrip('\r\n')
                try:
                    # 再循环内捕获异常 防止发生异常后退出交互式shell
                    line = self.precmd(line)
                    stop = self.onecmd(line)
                    stop = self.postcmd(stop, line)
                except Exception as e:
                    console.exception(e.args[0])
            self.postloop()
        finally:
            if self.use_rawinput and self.completekey:
                try:
                    import readline
                    readline.set_completer(self.old_completer)
                except ImportError:
                    pass

    @silentConsole
    def do_help(self, arg):
        """
        List available commands with "help" or detailed help with "help cmd".
        """
        if arg:
            # XXX check arg syntax
            try:
                func = getattr(self, 'help_' + arg)
            except AttributeError:
                try:
                    doc = getattr(self, 'do_' + arg).__doc__
                    if doc:
                        console.print("[green]%s[/green]\n" % str(doc))
                        return
                except AttributeError:
                    pass
                console.print("%s\n" % str(self.nohelp % (arg,)))
                return
            func()
        else:
            self.print_help()

    def preloop(self):
        """
        启动前加载命令参数提供的模块信息

        :return:
        """
        # 自动选择并使用命令行提供的模块
        module_info = None
        if env.CliOptions.module:
            module_info = self.getModuleInfoByArg(env.CliOptions.module.replace("\\", "/"))
        if module_info:
            self.do_use(module_info["path"])
        # 设置模块参数
        if env.CliOptions.options and self.currentModule:
            options = cli2args(env.CliOptions.options.split())
            allOpts = self.currentModule.get_allOpts()
            set_module_options(self.currentModule, options, allOpts)
        # 设置payload
        if env.CliOptions.payload and self.currentModule:
            self.do_set(f"PAYLOAD {env.CliOptions.payload}")
            if env.CliOptions.payload_opts:
                payload_obj, payload_option_list = getObjAndOpts(env.CliOptions.payload)
                options = cli2args(env.CliOptions.payload_opts.split())
                if payload_obj:
                    set_module_options(payload_obj, options, payload_option_list)
            # 设置编码器
            if env.CliOptions.encode and env.CliOptions.payload:
                self.do_set(f"ENCODER {env.CliOptions.encode}")
                if env.CliOptions.encode_opts:
                    encoder_obj, encoder_option_list = getObjAndOpts(env.CliOptions.encode)
                    options = cli2args(env.CliOptions.encode_opts)
                    if encoder_obj:
                        set_module_options(encoder_obj, options, encoder_option_list)
        # 设置host参数
        if env.CliOptions.host and self.currentModule:
            self.currentModule.add_host(env.CliOptions.host)

        self.postcmd(False, "")

    def postcmd(self, stop, line):
        """
        显示实时选择的模块

        :param stop:
        :param line:
        :return:
        """
        if self.currentModule:
            self.prompt = '[bold magenta]ExpDepos([bold green]{0}[/bold green])>[/bold magenta]' \
                .format(self.currentModule.SPEC.replace("modules.", "").replace(".", "/"))
        return stop

    def print_help(self):
        """
        格式化打印帮助信息

        :return:
        """
        for group in self.commands:
            print_doc_header(group)
            print_doc_header("Command", "Description", dash="-", style="deep_sky_blue4", prefix="\t")
            for command, description in self.commands[group].items():
                console.print("\t[bold yellow]" + command + "[/bold yellow]\t\t\t\t" + "[cyan]"
                              + description + "[/cyan]")
            console.print("")

    def do_test(self, ignore):
        allCommands = []
        for group in self.commands:
            console.print(self.commands[group].keys)

    @staticmethod
    def do_exit(ignore):
        """退出 ExpDepos"""
        return True

    @staticmethod
    def loadModule(module_info):
        console.debug("正在加载模块： [royal_blue1]{0}[/royal_blue1]".format(module_info["path"]))
        modulePath = format_module_path(module_info["path"])
        return ModuleLoader.load_module_from_file(modulePath)

    def isOptObj(self, current_mark):
        """
        检查当前设置项目是否为自定义类型

        """
        current_mark = current_mark.lower()
        module, option_list = self.whichModule(current_mark)
        if module and option_list:
            if current_mark in option_list and (isinstance(module.OPTIONS[current_mark], Option)):
                return module.OPTIONS[current_mark].type, module
        return current_mark, None

    def whichModule(self, current_mark):
        """
        检查current_mark属于哪个模块 并返回模块实力和全部参数列表

        """
        if key_is_in_module(current_mark, self.currentModule):
            return self.currentModule, self.currentModule.get_allOpts()
        payload = self.currentModule.get_option("payload", '')
        if payload:
            payload_obj, payload_option_list = getObjAndOpts(payload)
            if key_is_in_module(current_mark, payload_obj):
                return payload_obj, payload_obj.get_allOpts()
            if payload_obj:
                encoder = payload_obj.get_option("encoder", '')
                if encoder:
                    encoder_obj, encoder_option_list = getObjAndOpts(encoder)
                    if key_is_in_module(current_mark, encoder_obj):
                        return encoder_obj, encoder_obj.get_allOpts()
        return None, None
