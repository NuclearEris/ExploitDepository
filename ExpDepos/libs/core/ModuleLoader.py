#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/14 10:50
"""

import os
import re
import importlib
import sys
from importlib import util
from rich.progress import Progress
from pip._internal.cli.main import main as pip_installMain
from ExpDepos.libs.core.base.ExceptionBase import ExpDeposModuleException
from ExpDepos.libs.core.common.Common import console, none2str, bool2mark, format_module, deepListdir
from ExpDepos.libs.core.common.Common import Root_Path, env
from ExpDepos.libs.core.base.ModuleAnalyzer import ModuleAnalyzer
from ExpDepos.libs.core.common.Console import formatPgString


class ModuleLoader(object):
    """
    动态加载模块
    """

    @staticmethod
    def load_module_from_file(filepath, instDependency=True):
        """
        根据模块文件名加载模块

        :param filepath: 文件名路径，用于确定模块包路径及模块名
        :param instDependency: 当有未安装的模块时候是否提示安装
        :return: 已实例化的模块对象
        """
        if not filepath.endswith('.py'):
            filepath = filepath + '.py'
        # 检查模块依赖
        depend_module = ModuleLoader.check_module_dependency(filepath)
        console.debug("模块 '{0}' 依赖信息：{1}".format(filepath, depend_module['modules']))
        if len(depend_module['unload']) > 0 and instDependency is True:
            ModuleLoader.process_install_module(filepath=filepath, depend_module=depend_module)
        # 加载模块
        spec = ModuleLoader.get_spec(filepath)
        try:
            console.debug("使用模块SPEC：'{0}'".format(spec))
            module_name = ModuleLoader.get_filename(filepath, with_ext=False)
            if util.find_spec(spec) is None:
                raise ExpDeposModuleException("无法加载模块 {0} 请确认模块文件路径是否正确.".format(spec))
            module = importlib.import_module(spec)
            if module is None:
                raise ExpDeposModuleException("导入模块 {0} 失败 请确认模块文件路径及模块编写是否正确.".format(spec))
            console.debug("导入模块 {0}".format(module))
            try:
                module_class = getattr(module, module_name)
            except AttributeError:
                raise ExpDeposModuleException("模块 [magenta3]{0}[/magenta3] 中没有属性 [cyan]{1}[/cyan], "
                                              "请确认定义的模块类名是否和文件名一致(含大小写).".format(spec, module_name))
            module_exp = module_class()
            console.debug("从 {0} 中实例化对象 {1}".format(module_class, module_exp))
            if getattr(module_exp, "SPEC") is None:
                module_exp.SPEC = spec
            return module_exp
        except ModuleNotFoundError as e:
            raise ExpDeposModuleException("{0}.请确认模块是否正确或是第三方模块已正确安装.".format(str(e)))
        except FileNotFoundError:
            raise ExpDeposModuleException("加载模块文件是错误,请确认模块文件是否正确.")
        except NotImplementedError as e:
            raise ExpDeposModuleException("模块'{0}' 实现错误,请编写必要功能方法: {1}".format(spec, e.args[0]))
        except Exception as e:
            raise Exception(repr(e))

    @staticmethod
    def loadAllModules(filters=None):
        """
        加载全部模块信息

        :return:
        """
        if filters is None:
            filters = ['exploit', 'payload', 'encoder']
        allModules = []
        moduleFiles = deepListdir(env.Config.MODULES_PATH,
                                  exts=[".py"],
                                  exclude=["fingerprints", "__init__.py", "__pycache__"])
        with Progress() as progress:
            task = progress.add_task(formatPgString("[green]正在初始化模块库...[/green]"), total=len(moduleFiles))
            for moduleFile in moduleFiles:
                Analyzer = ModuleAnalyzer(filePath=moduleFile)
                try:
                    Analyzer.analysis()
                except Exception as e:
                    console.exception(repr(e))
                if Analyzer.assigns.get("Type") in filters:
                    formatModuleFile = moduleFile.replace(env.Config.DEPOS_PATH + os.sep, '')
                    module = None
                    alias = Analyzer.assigns.get("Alias", '')
                    # 检查重复别名
                    repeatAlias = [m for m in allModules if m['Alias'] == alias]
                    if repeatAlias:
                        progress.print(formatPgString(" 模块 [royal_blue1]{0}[/royal_blue1] 别名 "
                                                      "[bold green]{1}[/bold green] 已存在, 请重新命名."
                                                      .format(formatModuleFile,
                                                              alias),
                                                      level="WARNING"))
                        Analyzer.assigns.update({"Alias": ''})
                    # 尝试静默加载模块
                    tmpMsgLevel = console.getMsgLevel()
                    console.setMsgLeve(0)
                    try:
                        module = ModuleLoader.load_module_from_file(formatModuleFile, instDependency=False)
                        if module and (Analyzer.isExpModule or Analyzer.isPayload):
                            Analyzer.assigns.update({"vulType": module.VulType, "category": module.Category})
                    except Exception as e:
                        console.exception(repr(e))
                        progress.print(formatPgString(" 尝试加载模块 [royal_blue1]{0}[/royal_blue1] 失败: {1}"
                                                      .format(formatModuleFile, e.args[0]), level="WARNING"))
                    finally:
                        console.setMsgLeve(tmpMsgLevel)
                    module_info = {"module": module, "isLoad": True if module else False,
                                   "path": moduleFile.replace(env.Config.MODULES_PATH + os.sep, '')
                                                     .replace(os.sep, "/")
                                                     .replace('.py', '')
                                   }
                    # 如果模块正常加载 则从模块中获取属性值来更新module_info
                    module_info.update({attr: getattr(module, attr, Analyzer.assigns.get(attr))
                                        for attr in Analyzer.assigns.keys()} if module else Analyzer.assigns)
                    allModules.append(module_info)
                progress.update(task, advance=1)
        return allModules

    @staticmethod
    def get_spec(filepath):
        spec = ModuleLoader.get_dir(filepath, with_filename=True).replace(os.sep, '.')
        # 修复不同环境下传入的模块路径开头带有".\"或者"\"符号的兼容问题
        if not re.match(r"^modules.*", spec):
            spec = spec[spec.index("modules"):]
        return spec

    @staticmethod
    def get_filename(filepath, with_ext=True):
        base_name = os.path.basename(filepath)
        return base_name if with_ext else os.path.splitext(base_name)[0]

    @staticmethod
    def get_dir(filepath, with_filename=False):
        base_dir = os.path.dirname(filepath)
        file_name = ModuleLoader.get_filename(filepath, with_ext=False)
        return base_dir if not with_filename else base_dir + os.sep + file_name

    @staticmethod
    def get_envPaths(filepath):
        file_dir = Root_Path() + os.sep + (ModuleLoader.get_dir(filepath, False))
        console.debug("添加sys.path：{0}".format(file_dir))
        return sys.path.append(file_dir)

    @staticmethod
    def check_module_dependency(filepath):
        """
        检查Python源文件的模块依赖

        :param filepath: 要检查的Python源文件路径
        :return: 返回包含所有模块(modules)的依赖及未加载(unload)的依赖模块名字典
        """
        module_analyzer = ModuleAnalyzer(Root_Path() + os.sep + "ExpDepos" + os.sep + filepath)
        try:
            module_analyzer.analysis()
        except Exception as e:
            console.exception(repr(e))
        return {"modules": module_analyzer.modules, "unload": module_analyzer.unload_modules}

    @staticmethod
    def process_install_module(filepath, depend_module):
        console.warning("模块 '{0}' 未安装依赖：{1}".format(filepath, depend_module['unload']))
        choose = ''
        while choose.lower() != 'y' and choose.lower() != 'n':
            choose = console.input("[bold yellow]正在尝试安装依赖,该功能可能会安装未受信任的第三方模块,对您的计算机造成威胁! "
                                   "确认是否自动安装依赖?[bold yellow] [bold green]Y/N:[/bold green]")
        if choose == 'n':
            console.warning("已忽略为 '{0}' 安装依赖 {1}".format(filepath, depend_module['unload']))
            return None
        # 安装依赖模块
        ModuleLoader.install_module(depend_module['unload'])

    @staticmethod
    def install_module(modules):
        """
        使用pip安装第三方模块

        :param modules: 需要安装的第三方模块列表
        :return:
        """
        for module in modules:
            console.debug("正在尝试安装第三方模块：'{0}'".format(module))
            try:
                pip_installMain(['install', module])
            except Exception as e:
                raise Exception("尝试安装第三方模块 '{0}' 失败, 原因: {1}".format(module, repr(e)))

    @staticmethod
    def format_module_attr(value):
        """
        格式化模块基本信息

        :param value: 模块基本信息值
        :return: 格式化的字符串
        """
        format_str = ""
        if isinstance(value, list):
            for i, v in enumerate(value):
                if i != len(value) - 1:
                    format_str = format_str + v + "\n"
                else:
                    format_str = format_str + v
        else:
            format_str = value
        return str(format_str)

    @staticmethod
    def validation_is_static(key):
        """
        验证模块属性是否为用户自定义基本信息

        用户自定义模块基本信息(使用全大写或首字母大写方式,且由字母及下划线组成)
        :param key: 属性名称
        :return:
        """
        pattern = re.compile(r'[A-Z][_]?|^[A-Z].*[a-z][_]?')
        return pattern.match(key)

    @staticmethod
    def get_module_base_info(module_attr, module):
        """
        获取用户自定义的模块基本属性信息

        :param module_attr: 模块的属性字典
        :param module: exploit模块对象
        :return: 返回exploit模块中用户自定义的模块基本信息字典
        """
        base_info = dict()
        for key in module_attr:
            # 排除@property装饰的的函数 防止获取值时出现调用依赖问题
            if isinstance(getattr(type(module), key, None), property):
                continue
            value = getattr(module, key)
            if ModuleLoader.validation_is_static(key) \
                    and (value is not None) \
                    and key != "OPTIONS":
                base_info.update({key: value})
        return base_info

    @staticmethod
    def get_module_info(module):
        """
        获取模块属性信息

        :param module: exploit模块对象
        :return: 模块基本属性及用户自定义选项的字典
        """
        module_attr = dir(module)
        base_info = ModuleLoader.get_module_base_info(module_attr, module)
        console.debug("获取模块 {0} 用户自定义静态属性 {1}".format(module.Name, base_info.keys()))
        options_info = module.OPTIONS
        console.debug("获取模块 {0} 用户自定义选项信息 {1}".format(module.Name, options_info.keys()))
        return {"base_info": base_info, "options_info": options_info}

    @staticmethod
    def show_basic_info(module, base_info):
        # 使用rich.table格式化显示信息
        console.print("\nBasic Information([bold dark_red]{0}[/ bold dark_red])："
                      .format(format_module(base_info.get("SPEC"))), style="bold magenta3")
        table = console.rTable("Attr", "Description", style="cyan", box=console.rBox.SIMPLE_HEAD, width=90)
        # 按序先显示重点属性
        table.add_row("[bold green]Name[/bold green]", "[dodger_blue2]" + base_info.pop("Name"))
        table.add_row("[bold green]Module[/bold green]", "[dodger_blue2]" + format_module(base_info.pop("SPEC")))
        # 再显遍历显示剩余属性
        for key in base_info.keys():
            if key != "Description" and key != "References" and key != "Desc":
                table.add_row("[bold green]" + key + "[/bold green]",
                              "[dodger_blue2]" + ModuleLoader.format_module_attr(base_info.get(key)))
        console.print(table)

    @staticmethod
    def show_other_info(module, base_info):
        if 'Desc' in base_info:
            console.print("\nShort Description: ", style="bold magenta3")
            console.print(console.rMarkdown(base_info.pop("Desc")))
        if 'Description' in base_info:
            console.print("\nDetailed Description: ", style="bold magenta3")
            console.print(console.rMarkdown(base_info.pop("Description")))
        if 'References' in base_info:
            console.print("\nReferences: ", style="bold magenta3")
            console.print("\t" + ModuleLoader.format_module_attr(base_info.pop("References")).replace("\n", "\n\t"))

    @staticmethod
    def show_options(module, options_info):
        """
        显示模块用户自定义选项表

        :param module: exploit模块对象
        :param options_info: 模块选项列表
        :return:
        """
        table = console.rTable("Name", "Current Setting", "Type", console.rColumn("Required"),
                               "Description", style="cyan", box=console.rBox.SIMPLE_HEAD, width=120)
        for key in options_info.keys():
            table.add_row("[bold green]" + key.upper() + "[/bold green]",
                          "[bold yellow]" + none2str(module.get_option(key)) + "[/bold yellow]",
                          "[dodger_blue1]" + module.OPTIONS[key].type + "[/dodger_blue1]",
                          bool2mark(module.OPTIONS[key].require),
                          "[cyan]" + module.OPTIONS[key].description + "[cyan]")
        console.print(table)

    @staticmethod
    def show_module_info(module):
        """
        显示模块详细信息

        :param module: exploit模块对象
        :return:
        """
        module_info = ModuleLoader.get_module_info(module)
        base_info = module_info.pop("base_info")
        options_info = module_info.pop("options_info")

        console.debug("{0} 信息:".format(module.Name))
        # 显示基本信息
        ModuleLoader.show_basic_info(module, base_info)

        # 显示用户自定义属性表
        console.print("\nBasic Options: ", style="bold magenta3")
        ModuleLoader.show_options(module, options_info)

        # 最后显示描述及参考信息
        ModuleLoader.show_other_info(module, base_info)

    @staticmethod
    def show_all_modules(modules, filters=None):
        if filters is None:
            filters = ['exploit', 'payload', 'encoder']
        table = console.rTable("#", "Module", "Name", "Alias", "Type", "Rank", "Disclosure Date", "Description",
                               style="cyan", box=console.rBox.SIMPLE_HEAD)
        i = 1
        for module_info in modules:
            if module_info["Type"] in filters:
                table.add_row(str(i),
                              "[dodger_blue1]" + module_info["path"] + "[/dodger_blue1]",
                              "[bold green]" + module_info["Name"] + "[/bold green]",
                              "[bright_magenta]" + module_info["Alias"] + "[/bright_magenta]",
                              "[orchid]" + module_info["Type"] + "[/orchid]",
                              "[bold green]" + (module_info["Rank"] if 'Rank' in module_info else "Normal")
                              + "[/bold green]",
                              "[bold yellow]" + (
                                  module_info["Create_Date"] if 'Create_Date' in module_info else "unknown")
                              + "[/bold yellow]",
                              "[cyan]" + (module_info["Desc"] if 'Desc' in module_info else "")
                              + "[/cyan]")
                i += 1
        console.print(table)

    @staticmethod
    def show_all_alias(modules):
        table = console.rTable("#", "Alias", "Module", "Path", "Description",
                               style="cyan", box=console.rBox.SIMPLE_HEAD)
        i = 1
        for module_info in modules:
            table.add_row(str(i), "[bold green]" + module_info["Alias"] + "[/bold green]",
                          "[bold yellow]" + module_info["Name"] + "[/bold yellow]",
                          "[dodger_blue1]" + module_info["path"] + "[/dodger_blue1]",
                          "[cyan]" + (module_info["Desc"] if 'Desc' in module_info else "")
                          + "[cyan]")
            i += 1
        console.print(table)

    @staticmethod
    def show_all_fps(modules):
        table = console.rTable("#", "Name", "Author", "Version", "Type", "Description",
                               style="cyan", box=console.rBox.SIMPLE_HEAD)
        i = 0
        for module_info in modules:
            i += 1
            table.add_row(str(i), "[bold green]" + str(module_info.name) + "[/bold green]",
                          "[bold yellow]" + str(module_info.author) + "[/bold yellow]",
                          "[dodger_blue1]" + str(module_info.version) + "[/dodger_blue1]",
                          "[cyan]" + str(module_info.description)
                          + "[cyan]")
        console.print(table)

    @staticmethod
    def list_modules(types="modules", modules=None, filters=None):
        if filters is None:
            filters = ['exploit', 'payload', 'encoder']
        if modules is None:
            try:
                modules = getattr(env, types)
            except AttributeError as e:
                modules = env.modules
        if types == "modules":
            ModuleLoader.show_all_modules(modules, filters=filters)
        if types == "payloads":
            ModuleLoader.show_all_modules(modules, filters=['payload'])
        if types == "encoders":
            ModuleLoader.show_all_modules(modules, filters=['encoder'])
        if types == "exploits":
            ModuleLoader.show_all_modules(modules, filters=['exploit'])
        if types == "alias":
            ModuleLoader.show_all_alias(modules)
        if types == "fps":
            ModuleLoader.show_all_fps(modules)

    @staticmethod
    def set_module_opts(module, module_options):
        """
        批量设置模块用户自定义属性值

        :param module: exploit模块对象
        :param module_options: argparse 解析后的Namespace对象
        :return:
        """
        for key, value in vars(module_options).items():
            if value is not None:  # 设置参数的时候过滤未提供值的选项 否则会覆盖掉有默认值的选项
                module.set_option(key, value)

    @staticmethod
    def get_loaded_module(module, reload=False):
        for module_info in env.modules:
            if (module_info["path"] in module or module_info["Alias"] == module) and module_info["isLoad"]:
                if reload:
                    tmpMsgLevel = console.getMsgLevel()
                    console.setMsgLeve(0)
                    module_info["module"] = ModuleLoader.load_module_from_file("modules" + os.sep + module_info["path"])
                    console.setMsgLeve(tmpMsgLevel)
                return module_info
        return None

    @staticmethod
    def run_module(module, options):
        """
        加载并执行指定模块

        :param module: 模块路径
        :param options: AttribDict 运行模块的参数信息
        :return:
        """
        module_exp = None
        module_info = ModuleLoader.get_loaded_module(module)
        if module_info:
            module_exp = module_info["module"]
        if not module_exp:
            module_path = module.replace("\\", os.sep).replace("/", os.sep)
            console.info("正在加载模块 '{0}'".format(module_path))
            try:
                module_exp = ModuleLoader.load_module_from_file(module_path)
            except Exception as error:
                module_exp = None
                console.exception(repr(error))
            if module_exp is None:
                raise ExpDeposModuleException("模块 {0} 加载错误!".format(module_path))
            console.info("已加载模块 {0}".format(module_exp.Name))

        # 显示模块信息并退出
        if options.show_info:
            ModuleLoader.show_module_info(module_exp)
            exit()

        # 显示模块帮助信息并退出
        if options.module_help:
            module_exp.help()
            exit()
        return ModuleLoader.run_loaded_module(module_exp, options)

    @staticmethod
    def run_loaded_module(module_exp, options):
        """
        执行模块

        :param module_exp: 已实例化的模块对象
        :param options: AttribDict 运行模块的参数信息
        :return:
        """
        # 解析模块参数
        module_options = module_exp.parse_options(options.options)
        if module_options is not None:
            console.debug("解析到模块参数：{0}".format(module_options))
            # 设置模块参数
            console.info("设置模块参数：{0}".format(vars(module_options)))
            ModuleLoader.set_module_opts(module_exp, module_options)
        # 设置HOST参数值
        if options.host:
            module_exp.add_host(options.host)
        console.debug("模块当前设置：{0}".format(module_exp.get_options()))

        # 默认以 verify 模式运行
        module_exp.run(options, "exploit" if options.exploit else "verify")
        console.debug("模块 '{0}' 执行结果：{1}".format(module_exp.Name, module_exp.result))
        return module_exp.result
