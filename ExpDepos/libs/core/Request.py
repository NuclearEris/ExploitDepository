#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/8/2 20:43
"""

import re
import typing
import time
import hmac
import json
import base64
import httpx
import random
import asyncio
import datetime
import hashlib
import warnings

from functools import wraps
from httpx import Response, BaseTransport, AsyncBaseTransport, Request, Timeout, URL, Headers
from httpx._client import UseClientDefault, USE_CLIENT_DEFAULT, BoundSyncStream, BoundAsyncStream, logger, \
    ClientState
from httpx._config import DEFAULT_TIMEOUT_CONFIG, Limits, DEFAULT_LIMITS, DEFAULT_MAX_REDIRECTS
from httpx._types import URLTypes, QueryParamTypes, HeaderTypes, CookieTypes, AuthTypes, TimeoutTypes, VerifyTypes, \
    CertTypes, ProxiesTypes, RequestContent, RequestData, RequestFiles
from httpx._utils import Timer
from httpx._transports.base import SyncByteStream, AsyncByteStream
from httpx._exceptions import request_context
from ExpDepos.libs.core.Response import Response as ExtendResponse
from ExpDepos.libs.core.common.Common import console
from ExpDepos.libs.core.base.RequestBase import RequestBase
from ExpDepos.libs.core.base.ExceptionBase import ExploitValidationException


def randomAgent():
    """
    随机User-Agent

    :return: 适用于HTTP Header的User-Agent
    """
    agents = ['Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.2; WOW64; Trident/7.0)',
              'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; Touch; rv:11.0) like Gecko',
              'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 '
              'Safari/537.36',
              'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_0) AppleWebKit/537.36 (KHTML, like Gecko) '
              'Chrome/91.0.4472.114 Safari/537.36',
              'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.9 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 '
              'Safari/537.36 Edg/91.0.864.67',
              'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'Mobile/15E148',
              'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 '
              'Safari/537.36',
              'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:71.0) Gecko/20100101 Firefox/71.0',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 '
              'Safari/537.36',
              'Mozilla/5.0 (Linux; U; Android 8.1.0; zh-CN; EML-AL00 Build/HUAWEIEML-AL00) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/57.0.2987.108 baidu.sogo.uc.UCBrowser/11.9.4.974 ',
              'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)',
              'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4 240.111 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36',
              'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)',
              'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'Mobile/15E148',
              'Mozilla/5.0 (Windows NT 5.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 '
              'Safari/537.36',
              'Mozilla/5.0 (Linux; Android 11; V2047A Build/RP1A.200720.012; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:76.0) Gecko/20100101 Firefox/76.0',
              'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; znwb7900; SLCC2; .NET CLR '
              '2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2)',
              'Mozilla/5.0 (X11; Linux i686; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 '
              'Safari/537.36',
              'Mozilla/5.0 (Linux; Android 10; ELE-AL00 Build/HUAWEIELE-AL00; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/81.0.4044.138 Mobile Safari/537.36',
              'Dalvik/2.1.0 (Linux; U; Android 10; ELE-AL00 Build/HUAWEIELE-AL00)',
              'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET '
              'CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)',
              'Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (Linux; Android 10; LIO-AN00 Build/HUAWEILIO-AN00; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Dalvik/2.1.0 (Linux; U; Android 10; LIO-AN00 Build/HUAWEILIO-AN00)',
              'Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (iPhone; CPU iPhone OS 14_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'Mobile/15E148',
              'Mozilla/5.0 (iPhone; CPU iPhone OS 13_6_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'Mobile/15E148',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0',
              'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0)',
              'Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko',
              'Mozilla/5.01715179 Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
              'Chrome/68.0.3440.106 Safari/537.36 OPR/55.0.2994.44',
              'Mozilla/5.0 (Linux; Android 10; LYA-AL00 Build/HUAWEILYA-AL00; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Dalvik/2.1.0 (Linux; U; Android 10; LYA-AL00 Build/HUAWEILYA-AL00)',
              'Mozilla/5.0 (Windows NT 6.2; Trident/7.0; rv:11.0) like Gecko',
              'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET '
              'CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2)',
              'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'Version/13.1.2 Safari/605.1.15',
              'Mozilla/5.0 (Linux; Android 10; HMA-AL00 Build/HUAWEIHMA-AL00; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 '
              'Safari/537.36 QIHU 360SE',
              'Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0',
              'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3018.0 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 '
              'Safari/537.36',
              'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) '
              'Chrome/84.0.4147.125 Safari/537.36',
              'Mozilla/5.0 (Linux; Android 10; VOG-AL10 Build/HUAWEIVOG-AL10; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Mozilla/5.0 (Linux; Android 10; AKA-AL10 Build/HONORAKA-AL10; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36',
              'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.89 '
              'Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 '
              'Safari/537.36',
              'Mozilla/5.0 (Linux; Android 11; M2102J2SC Build/RKQ1.200826.002; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/87.0.4280.141 Mobile Safari/537.36',
              'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0',
              'Mozilla/5.0 (Linux; Android 8.1.0; 16th Plus Build/OPM1.171019.026; wv) AppleWebKit/537.36 (KHTML, '
              'like Gecko) Version/4.0 Chrome/66.0.3359.159 Mobile Safari/537.36',
              'Mozilla/5.0 (iPod; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) '
              'CriOS/84.0.4147.122 Mobile/15E148 Safari/604.1']
    return random.choice(agents).strip()


def parseHeaders(options):
    """
    解析命令行header值

    :param options: 命令行参数
    :return: 适用于request请求的http header字典
    """
    headers = dict()
    if options.header is not None:
        for values in options.header.split(","):
            value = values.split(":")
            headers.update({value[0]: value[1]})
    # User-Agent 设置
    if options.agent is not None:
        headers['User-Agent'] = options.agent
    else:
        headers['User-Agent'] = randomAgent()

    # referer 设置
    if options.referer is not None:
        headers['Referer'] = options.referer

    return headers


def parseCookies(options):
    """
    解析命令行cookie值

    :param options: 命令行参数
    :return: 适用于request请求的httpx.Cookies实例
    """
    cookies = httpx.Cookies()
    cookie_values = options.cookie
    values = None
    if cookie_values is not None:
        # 完整cookie字符串使用";"分隔
        if ";" in cookie_values:
            values = cookie_values.split(";")
        # 自定义输入键值对为","分隔
        if "," in cookie_values:
            values = cookie_values.split(",")
        if not isinstance(values, list):
            values = [cookie_values]
        for value in values:
            value = value.strip()
            # 完整cookie字符串使用"="分隔cookie名与cookie值
            if "=" in value:
                # 兼容ASP多为数组构成的cookie情况(name=val_name=val_value)
                if "&" in value or value.count("=") > 1:
                    value = value.split("=")
                    cookies.set(value[0], "=".join(value[1:]))
                else:
                    cookie = value.split("=")
                    cookies.set(cookie[0], cookie[1])
            # 自定义输入键值对为":"分隔cookie名与cookie值
            if ":" in value:
                cookie = value.split(":")
                cookies.set(cookie[0], cookie[1])
    return cookies


def parseAuthentication(options):
    """
    解析命令行HTTP基础认证信息

    :param options: 命令参数
    :return: httpx.DigestAuth实例
    """
    if options.auth is not None:
        auth = options.auth.split(":")
        if auth[0] and auth[1]:
            return httpx.DigestAuth(auth[0], auth[1])
    return None


def parseProxy(options):
    """
    解析命令行proxy值

    :param options: 命令行参数
    :return: httpx.proxy
    """
    if options.proxy is not None:
        # 验证代理格式
        proxy_regex = r"([a-z-A-Z0-9]){4,7}://((.*):(.*)@)?(?:" \
                      r"(([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}|localhost" \
                      r"|((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3})" \
                      r"(\:([0-9]|[1-9]\d{1,3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])/?)" \
                      r")$"
        if not re.match(proxy_regex, options.proxy):
            raise ExploitValidationException("代理格式错误, 请使用('protocol://username:password@host:port')格式")
        return httpx.Proxy(
            options.proxy
        )
    return None


def parseHost(options):
    """
    格式化host值 默认采用http协议

    :param options: 命令行参数
    :return: string
    """
    if options.host is not None:
        if not re.match("^(https?://)", options.host):
            return 'http://{0}'.format(options.host)
        return options.host
    return ''


def instance(options, isSync=False):
    """
    初始化Request对象

    :param options: AttribDict 初始化参数 用构造Httpx.Client对象的请求参数
    :param isSync: 是否获取适用于异步请求的AsyncClient对象
    :return: 已扩展httpx.Client Request对象或是已扩展httpx.AsyncClient的AsyncRequest对象
    """
    hooks = {'request': [requestHandler], 'response': [responseHandler]}
    if isSync:
        hooks = {'request': [asyncRequestHandler], 'response': [asyncResponseHandler]}
    headers = parseHeaders(options)
    cookies = parseCookies(options)
    auth = parseAuthentication(options)
    proxy = parseProxy(options)
    host = parseHost(options)
    timeout = options.timeout
    retries = options.retries
    rdelay = options.rdelay
    delay = options.delay
    useScf = options.useScf
    if not isSync:
        return Request(
            event_hooks=hooks,
            base_url=host,
            headers=headers,
            cookies=cookies,
            auth=auth,
            proxies=proxy,
            timeout=timeout,
            verify=False,
            retries=retries,
            rdelay=rdelay,
            delay=delay,
            useScf=useScf,
        )
    else:
        return AsyncRequest(
            event_hooks=hooks,
            base_url=host,
            headers=headers,
            cookies=cookies,
            auth=auth,
            proxies=proxy,
            timeout=timeout,
            verify=False,
            retries=retries,
            rdelay=rdelay,
            delay=delay,
            useScf=useScf,
        )


def requestHandler(request):
    """
    Httpx request hook

    :param request:
    :return:
    """
    pass


def responseHandler(response):
    """
    Httpx response hook

    :param response:
    :return:
    """
    return reBuildResp(response)


async def asyncRequestHandler(request):
    """
    Httpx async request hook

    :param request:
    :return:
    """
    pass


async def asyncResponseHandler(response):
    """
    Httpx async response hook

    :param response:
    :return:
    """
    return reBuildResp(response)


def reBuildResp(response):
    """
    使用云函数代理请求之后重构Response对象

    :param response:
    :return:
    """
    mark = False
    scfMark = ["X-Api-FuncName", "X-Api-ID", "X-Api-AppId", "X-Api-RequestId"]
    for key in scfMark:
        if key in response.headers:
            mark = True
            break
    if mark:
        try:
            scfResponseContent = json.loads(response.text)
            content = base64.b64decode(scfResponseContent["body"]) \
                if scfResponseContent["isBase64Encoded"] else scfResponseContent["body"]
            # 添加unsetEncoding移除header头中的Content-Encoding头
            # 防止重构Response对象时候对内容进行二次解码报错
            headers = Headers(unsetEncoding(json.loads(scfResponseContent["headers"])))
            statusCode = scfResponseContent["statusCode"]
            request = json.loads(scfResponseContent["request"])
            response.request.url = URL(request["url"]).copy_merge_params(params=request["params"]) \
                if request["params"] else URL(request["url"])
            response.request.headers = Headers(request["headers"])
            rebuildResp = ExtendResponse(status_code=statusCode,
                                         headers=headers,
                                         content=content,
                                         request=response.request)
            return rebuildResp
        except Exception:
            return response
    return response


def unsetEncoding(headers: dict) -> dict:
    """
    删除headers中的Content-Encoding

    :param headers: 请求头
    :return: dict headers
    """
    return {key: value for key, value in headers.items() if key.lower() != "content-encoding"}


def signAuth(source, SecretId, SecretKey):
    """
    认证签名计算

    :param source: 自定义水印信息
    :param SecretId: 秘钥ID
    :param SecretKey: 秘钥Key
    :return:
    """
    dateTime = datetime.datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S GMT')
    auth = "hmac id=\"" + SecretId + "\", algorithm=\"hmac-sha1\", headers=\"date source\", signature=\""
    signStr = "date: " + dateTime + "\n" + "source: " + source
    sign = hmac.new(SecretKey.encode(), signStr.encode(), hashlib.sha1).digest()
    sign = base64.b64encode(sign).decode()
    sign = auth + sign + "\""
    return sign, dateTime


def setAuthHeader(header, scfApi):
    """
    在HTTP header中设置签名请求

    :param header: HTTP Header
    :param scfApi: 云函数API网关配置信息
    :return:
    """
    if scfApi["accessKeys"] and "AccessKeyId" in scfApi["accessKeys"]:
        source = "Request From ExploitDepository"
        sign, dateTime = signAuth(source=source,
                                  SecretId=scfApi["accessKeys"]["AccessKeyId"],
                                  SecretKey=scfApi["accessKeys"]["AccessKeySecret"])
        header.update({
            "Authorization": sign,
            "Date": dateTime,
            "Source": source,

        })
    return header


def checkIsURL(args):
    """
    检查参数是否为正常的URL地址

    :param args:
    :return:
    """
    url = URL(args)
    if url.scheme and url.host and url.path:
        return str(url)
    return False


def wrapsMethods(method):
    """
    为httpx的请求方法添加装饰器 以实现delay及retries功能

    :param method: 需要装饰的方法对象
    :return: 已装饰的方法对象
    """

    @wraps(method)
    def wrapper(self, *args, **kwargs):
        retries_count = 0
        response = None
        # 请求失败后重试
        while response is None and retries_count <= self.retries:
            if self.useScf:  # 使用云函数代理请求
                if 'method' in kwargs:
                    request_method = kwargs.pop("method")
                else:
                    request_method = args[0]
                if 'url' in kwargs:
                    url = kwargs.pop("url")
                else:
                    url = args[1]
                isUrl = checkIsURL(url)
                if isUrl:
                    endPoint = isUrl
                else:
                    sep = "" if str(self.base_url).endswith("/") else "/"
                    endPoint = str(self.base_url) + sep + url.lstrip("/")
                scfApi = self.scfApiRandom()  # 随机选择网关地址
                header = {"proxy_endpoint": endPoint}  # 将最终请求地址放在headers中
                if scfApi:
                    console.debug("使用 [blue]{user}[/blue] [magenta3]{cloudType} Cloud[/magenta3]"
                                  " [green]{region}[/green] 地区API网关: {api}".format(user=scfApi["user"],
                                                                                   cloudType=scfApi["cloudType"],
                                                                                   region=scfApi["region"],
                                                                                   api=scfApi["api"]))
                    apiUrl = URL(scfApi["api"])
                    self.headers = setAuthHeader(header=header, scfApi=scfApi)  # 请求头中添加认证信息
                    response = method(self, method=request_method, url=apiUrl, **kwargs)  # 重构请求
            else:
                response = method(self, *args, **kwargs)
            if not response and retries_count < self.retries:
                console.warning("第 {0} 次请求失败 将在 {1} 秒后重试第 {2} 次请求..."
                                .format(retries_count + 1, self.rdelay, retries_count + 2))
                # 重试的时候使用重试间隔时间,与请求间隔时间分开
                time.sleep(self.rdelay)
            else:
                # 请求间隔时间
                time.sleep(self.delay)
            retries_count = retries_count + 1
        return response

    return wrapper


def wrapsAsyncMethods(method):
    """
    为httpx的异步请求方法添加装饰器 以实现delay及retries功能

    :param method: 需要装饰的方法对象
    :return: 已装饰的方法对象
    """

    @wraps(method)
    async def wrapper(self, *args, **kwargs):
        retries_count = 0
        response = None
        # 请求失败后重试
        while response is None and retries_count <= self.retries:
            if self.useScf:  # 使用云函数代理请求
                if 'method' in kwargs:
                    request_method = kwargs.pop("method")
                else:
                    request_method = args[0]
                if 'url' in kwargs:
                    url = kwargs.pop("url")
                else:
                    url = args[1]
                isUrl = checkIsURL(url)
                if isUrl:
                    endPoint = isUrl
                else:
                    sep = "" if str(self.base_url).endswith("/") else "/"
                    endPoint = str(self.base_url) + sep + url.lstrip("/")
                scfApi = self.scfApiRandom()  # 随机选择网关地址
                header = {"proxy_endpoint": endPoint}  # 将最终请求地址放在headers中
                if scfApi:
                    # console.debug("使用 [blue]{user}[/blue] [cyan]{cloudType} Cloud[/cyan] [green]{region}[/green]"
                    #               " 地区API网关: {api}".format(user=scfApi["user"],
                    #                                        cloudType=scfApi["cloudType"],
                    #                                        region=scfApi["region"],
                    #                                        api=scfApi["api"]))
                    apiUrl = URL(scfApi["api"])
                    self.headers = setAuthHeader(header=header, scfApi=scfApi)  # 请求头中添加认证信息
                    response = await method(self, method=request_method, url=apiUrl, **kwargs)  # 重构请求
            else:
                response = await method(self, *args, **kwargs)
            if not response and retries_count < self.retries:
                console.warning("第 {0} 次请求失败 将在 {1} 秒后重试第 {2} 次请求..."
                                .format(retries_count + 1, self.rdelay, retries_count + 2))
                # 重试的时候使用重试间隔时间,与请求间隔时间分开
                # time.sleep(self.rdelay)
                await asyncio.sleep(self.rdelay)
            else:
                # 请求间隔时间
                # time.sleep(self.delay)
                await asyncio.sleep(self.delay)
            retries_count = retries_count + 1
        return response

    return wrapper


class Request(RequestBase, httpx.Client):
    """
    HTTP 同步请求接口
    """

    def __init__(self,
                 *,
                 auth: AuthTypes = None,
                 params: QueryParamTypes = None,
                 headers: HeaderTypes = None,
                 cookies: CookieTypes = None,
                 verify: VerifyTypes = True,
                 cert: CertTypes = None,
                 http1: bool = True,
                 http2: bool = False,
                 proxies: ProxiesTypes = None,
                 mounts: typing.Mapping[str, BaseTransport] = None,
                 timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
                 limits: Limits = DEFAULT_LIMITS,
                 max_redirects: int = DEFAULT_MAX_REDIRECTS,
                 event_hooks: typing.Mapping[str, typing.List[typing.Callable]] = None,
                 base_url: URLTypes = "",
                 transport: BaseTransport = None,
                 app: typing.Callable = None,
                 trust_env: bool = True,
                 retries: int = 0,
                 rdelay: int = 0,
                 delay: int = 0,
                 useScf: bool = False,
                 scfCfg: dict = dict(), ):
        """
        扩展和封装httpx.Client对象

        :param auth: (optional)An authentication class to use when sending requests.
        :param params: (optional)Query parameters to include in request URLs,
                        as a string, dictionary, or sequence of two-tuples.
        :param headers: (optional)Dictionary of HTTP headers to include when sending requests.
        :param cookies: (optional)Dictionary of Cookie items to include when sending requests.
        :param verify: (optional)SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts.
                        Either True (default CA bundle), a path to an SSL certificate file,
                        an ssl.SSLContext, or False (which will disable verification).
        :param cert: (optional)An SSL certificate used by the requested host to authenticate the client.
                        Either a path to an SSL certificate file, or two-tuple of (certificate file, key file),
                         or a three-tuple of (certificate file, key file, password).
        :param http1: (optional)A boolean indicating if HTTP/1 support should be enabled. Defaults to True.
        :param http2: (optional)A boolean indicating if HTTP/2 support should be enabled. Defaults to False.
        :param proxies: (optional)A dictionary mapping HTTP protocols to proxy URLs.
        :param timeout: (optional) The timeout configuration to use when sending requests.
        :param limits: (optional) The limits configuration to use.
        :param max_redirects: (optional) The maximum number of redirect responses that should be
        :param base_url: (optional) A URL to use as the base when building request URLs.
        :param transport: (optional) A transport class to use for sending requests over the network.
        :param app: (optional) An ASGI application to send requests to, rather than sending actual network requests.
        :param trust_env: (optional) Enables or disables usage of environment variables for configuration.
        :param retries: 请求失败后重试次数
        :param delay: 两次请求之间的间隔时间
        :param rdelay: 请求失败后重试间隔时间
        :param useScf: 是否使用云函数代理
        :param scfCfg: 云函数配置信息
        """
        super().__init__(
            auth=auth,
            params=params,
            headers=headers,
            cookies=cookies,
            verify=verify,
            cert=cert,
            http1=http1,
            http2=http2,
            proxies=proxies,
            mounts=mounts,
            timeout=timeout,
            limits=limits,
            max_redirects=max_redirects,
            event_hooks=event_hooks,
            base_url=base_url,
            transport=transport,
            app=app,
            trust_env=trust_env,
            retries=retries,
            rdelay=rdelay,
            delay=delay,
            useScf=useScf,
            scfCfg=scfCfg
        )

    def send(
            self,
            request: Request,
            *,
            stream: bool = False,
            auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
            allow_redirects: bool = True,
            timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        重载httpx.Client的send方法，实现使用hook的时候可以更改response对象
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")

        self._state = ClientState.OPENED
        timeout = (
            self.timeout if isinstance(timeout, UseClientDefault) else Timeout(timeout)
        )

        auth = self._build_request_auth(request, auth)

        response = self._send_handling_auth(
            request,
            auth=auth,
            timeout=timeout,
            allow_redirects=allow_redirects,
            history=[],
        )
        try:
            if not stream:
                response.read()

            for hook in self._event_hooks["response"]:
                hooksReturn = hook(response)  # 调用response的hook后可以修改response并返回
                if hooksReturn:
                    response = hooksReturn

            return response

        except Exception as exc:
            response.close()
            raise exc

    @wrapsMethods
    def request(
        self,
        method: str,
        url: URLTypes,
        *,
        content: RequestContent = None,
        data: RequestData = None,
        files: RequestFiles = None,
        json: typing.Any = None,
        params: QueryParamTypes = None,
        headers: HeaderTypes = None,
        cookies: CookieTypes = None,
        auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
        allow_redirects: bool = True,
        timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Build and send a request.

        Equivalent to:

        ```python
        request = client.build_request(...)
        response = client.send(request, ...)
        ```

        See `Client.build_request()`, `Client.send()` and
        [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.

        [0]: /advanced/#merging-of-configuration
        """
        if cookies is not None:
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning)

        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
        )
        return self.send(
            request, auth=auth, allow_redirects=allow_redirects, timeout=timeout
        )

    def _send_single_request(self, request: Request, timeout: Timeout) -> Response:
        """
        重写httpx.Client的_send_single_request方法
        用于扩展Response为ExpDepos.libs.core.Response.Response

        :param request:
        :param timeout:
        :return:
        """
        transport = self._transport_for_url(request.url)
        timer = Timer()
        timer.sync_start()

        if not isinstance(request.stream, SyncByteStream):
            raise RuntimeError(
                "Attempted to send an async request with a sync Client instance."
            )

        with request_context(request=request):
            (status_code, headers, stream, extensions) = transport.handle_request(
                request.method.encode(),
                request.url.raw,
                headers=request.headers.raw,
                stream=request.stream,
                extensions={"timeout": timeout.as_dict()},
            )

        response = ExtendResponse(  # 将response类型更改为ExpDepos.libs.core.Response.Response
            status_code,
            headers=headers,
            stream=stream,
            extensions=extensions,
            request=request,
        )

        response.stream = BoundSyncStream(stream, response=response, timer=timer)
        self.cookies.extract_cookies(response)

        status = f"{response.status_code} {response.reason_phrase}"
        response_line = f"{response.http_version} {status}"
        logger.debug(f'HTTP Request: {request.method} {request.url} "{response_line}"')

        return response


class AsyncRequest(RequestBase, httpx.AsyncClient):
    """
    HTTP 异步请求接口
    """

    def __init__(self, *,
                 auth: AuthTypes = None,
                 params: QueryParamTypes = None,
                 headers: HeaderTypes = None,
                 cookies: CookieTypes = None,
                 verify: VerifyTypes = True,
                 cert: CertTypes = None,
                 http1: bool = True,
                 http2: bool = False,
                 proxies: ProxiesTypes = None,
                 mounts: typing.Mapping[str, AsyncBaseTransport] = None,
                 timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
                 limits: Limits = DEFAULT_LIMITS,
                 max_redirects: int = DEFAULT_MAX_REDIRECTS,
                 event_hooks: typing.Mapping[str, typing.List[typing.Callable]] = None,
                 base_url: URLTypes = "",
                 transport: AsyncBaseTransport = None,
                 app: typing.Callable = None,
                 trust_env: bool = True,
                 retries: int = 0,
                 rdelay: int = 0,
                 delay: int = 0,
                 useScf: bool = False,
                 scfCfg: dict = dict(), ):
        """
        扩展和封装httpx.AsyncClient对象

        :param auth: (optional)An authentication class to use when sending requests.
        :param params: (optional)Query parameters to include in request URLs,
                        as a string, dictionary, or sequence of two-tuples.
        :param headers: (optional)Dictionary of HTTP headers to include when sending requests.
        :param cookies: (optional)Dictionary of Cookie items to include when sending requests.
        :param verify: (optional)SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts.
                        Either True (default CA bundle), a path to an SSL certificate file,
                        an ssl.SSLContext, or False (which will disable verification).
        :param cert: (optional)An SSL certificate used by the requested host to authenticate the client.
                        Either a path to an SSL certificate file, or two-tuple of (certificate file, key file),
                         or a three-tuple of (certificate file, key file, password).
        :param http1: (optional)A boolean indicating if HTTP/1 support should be enabled. Defaults to True.
        :param http2: (optional)A boolean indicating if HTTP/2 support should be enabled. Defaults to False.
        :param proxies: (optional)A dictionary mapping HTTP protocols to proxy URLs.
        :param timeout: (optional) The timeout configuration to use when sending requests.
        :param limits: (optional) The limits configuration to use.
        :param max_redirects: (optional) The maximum number of redirect responses that should be
        :param base_url: (optional) A URL to use as the base when building request URLs.
        :param transport: (optional) A transport class to use for sending requests over the network.
        :param app: (optional) An ASGI application to send requests to, rather than sending actual network requests.
        :param trust_env: (optional) Enables or disables usage of environment variables for configuration.
        :param retries: 请求失败后重试次数
        :param delay: 两次请求之间的间隔时间
        :param rdelay: 请求失败后重试间隔时间
        :param useScf: 是否使用云函数代理
        :param scfCfg: 云函数配置信息
        """
        super().__init__(auth=auth,
                         params=params,
                         headers=headers,
                         cookies=cookies,
                         verify=verify,
                         cert=cert,
                         http1=http1,
                         http2=http2,
                         proxies=proxies,
                         mounts=mounts,
                         timeout=timeout,
                         limits=limits,
                         max_redirects=max_redirects,
                         event_hooks=event_hooks,
                         base_url=base_url,
                         transport=transport,
                         app=app,
                         trust_env=trust_env,
                         retries=retries,
                         rdelay=rdelay,
                         delay=delay,
                         useScf=useScf,
                         scfCfg=scfCfg)

    async def send(
            self,
            request: Request,
            *,
            stream: bool = False,
            auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
            allow_redirects: bool = True,
            timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        重载httpx.AsyncClient的send方法，实现使用hook的时候可以更改response对象
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")

        self._state = ClientState.OPENED
        timeout = (
            self.timeout if isinstance(timeout, UseClientDefault) else Timeout(timeout)
        )

        auth = self._build_request_auth(request, auth)

        response = await self._send_handling_auth(
            request,
            auth=auth,
            timeout=timeout,
            allow_redirects=allow_redirects,
            history=[],
        )
        try:
            if not stream:
                await response.aread()

            for hook in self._event_hooks["response"]:
                hooksReturn = await hook(response)  # 调用response的hook后可以修改response并返回
                if hooksReturn:
                    response = hooksReturn

            return response

        except Exception as exc:
            await response.aclose()
            raise exc

    @wrapsAsyncMethods
    async def request(
        self,
        method: str,
        url: URLTypes,
        *,
        content: RequestContent = None,
        data: RequestData = None,
        files: RequestFiles = None,
        json: typing.Any = None,
        params: QueryParamTypes = None,
        headers: HeaderTypes = None,
        cookies: CookieTypes = None,
        auth: typing.Union[AuthTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
        allow_redirects: bool = True,
        timeout: typing.Union[TimeoutTypes, UseClientDefault] = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Build and send a request.

        Equivalent to:

        ```python
        request = client.build_request(...)
        response = await client.send(request, ...)
        ```

        See `AsyncClient.build_request()`, `AsyncClient.send()`
        and [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.

        [0]: /advanced/#merging-of-configuration
        """
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
        )
        response = await self.send(
            request, auth=auth, allow_redirects=allow_redirects, timeout=timeout
        )
        return response

    async def _send_single_request(self, request: Request, timeout: Timeout) -> Response:
        """
        重写httpx.AsyncClient的_send_single_request方法
        用于扩展Response为ExpDepos.libs.core.Response.Response

        :param request:
        :param timeout:
        :return:
        """
        transport = self._transport_for_url(request.url)
        timer = Timer()
        await timer.async_start()

        if not isinstance(request.stream, AsyncByteStream):
            raise RuntimeError(
                "Attempted to send an sync request with an AsyncClient instance."
            )

        with request_context(request=request):
            (
                status_code,
                headers,
                stream,
                extensions,
            ) = await transport.handle_async_request(
                request.method.encode(),
                request.url.raw,
                headers=request.headers.raw,
                stream=request.stream,
                extensions={"timeout": timeout.as_dict()},
            )

        response = ExtendResponse(  # 将response类型更改为ExpDepos.libs.core.Response.Response
            status_code,
            headers=headers,
            stream=stream,
            extensions=extensions,
            request=request,
        )

        response.stream = BoundAsyncStream(stream, response=response, timer=timer)
        self.cookies.extract_cookies(response)

        status = f"{response.status_code} {response.reason_phrase}"
        response_line = f"{response.http_version} {status}"
        logger.debug(f'HTTP Request: {request.method} {request.url} "{response_line}"')

        return response

