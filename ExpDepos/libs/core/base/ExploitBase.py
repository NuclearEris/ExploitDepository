#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/8 16:22
"""

import asyncio
import ExpDepos.libs.core.Request as Request
import ExpDepos.libs.core.Response as Response
from ExpDepos.libs.core.base.ExceptionBase import *
from ExpDepos.libs.core.base.OptionsBase import *
from ExpDepos.libs.core.common.Common import *
from ExpDepos.libs.core.common.Result import Result
from ExpDepos.libs.core.common.Enums import EXP_CATEGORY, VUL_TYPE, FINGERPRINT
from ExpDepos.libs.core.base.Fingerprint import Fingerprint, register, instanceFingerprint, availableFilters


class ExploitBase(object):
    """
    Exp基类，用于定义每个exp默认方法及规则
    """
    Name = None  # exp名称
    Alias = None  # 漏洞别名
    Author = None  # 编写作者
    VulType = None  # 漏洞类型
    Category = None  # 漏洞分类
    Create_Date = None  # exp编写日期
    Update_Date = None  # exp更新日期
    Rank = None  # exp效果(可选：Excellent Great Good Normal Average Low Manual)
    AppPowerLink = None  # 漏洞厂商主页地址
    AppName = None  # 漏洞应用名称
    AppVersion = None  # 漏洞影响版本
    References = []
    Desc = """
        """
    Description = """
            """
    SPEC = None  # 模块SPEC，无需自定义，加载时候自动设置

    def __init__(self):
        # 用于存储EXP额外选项
        self.OPTIONS = dict()
        if hasattr(self, "_options") \
                and len(self._options()) > 0:
            # 将用户自定义选项名全部转换为小写，以便在命令行使用-P或者--options选项传入
            self.OPTIONS.update({key.lower(): value for key, value in self._options().items()})
        # 初始化 host 参数 防止与用户自定义参数冲突
        self.OPTIONS.update({'host': OptString("", description="目标地址 (可选IP端口或URL地址)", require=False)})

        self.opt_parse = None  # 使用argparse.ArgumentParser解析的模块参数对象
        self.requireOpts = None  # 模块用户自定义的必须参数
        self.result = None  # 模块执行结果
        self.request = None  # HTTP同步请求接口
        self.asyncRequest = None  # HTTP异步请求接口

    @property
    def fingerprint(self) -> any:
        """
        识别目标指纹信息

        :return:    指纹信息实例
        """
        fp = None
        try:
            fp = self._fingers()
        except NotImplementedError:
            console.warning("[green]{0}[/green] 未实现指纹识别功能, 请重载[magenta3]_fingers()[/magenta3]方法."
                            .format(self.Name))
            return None
        if fp:
            fp.update({"regByExp": self.SPEC})
            register(fp)
            return instanceFingerprint(fp)
        return None

    def fpMatches(self, response: Response, mode="ALL", fpFilter={}) -> list:
        """
        指纹识别

        :param response: Response 对象
        :param mode: 识别模式 可选ALL、PASS, AGGR, EXP
        :param fpFilter: 指纹过滤器 用于过滤包含指定过滤器的指纹
        :return: list
        """
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_until_complete(self.asyncFpMatches(response=response,
                                                                               mode=mode,
                                                                               fpFilter=fpFilter))

    async def asyncFpMatches(self, response: Response, mode="ALL", fpFilter={}) -> list:
        """
        并发指纹识别

        :param response: Response 对象
        :param mode: 识别模式 可选ALL、PASS, AGGR, EXP
        :param fpFilter: 指纹过滤器 用于过滤包含指定过滤条件的指纹
        :return: list
        """
        sem = asyncio.Semaphore(env.CliOptions.thread)

        async def aw_task(aw):
            async with sem:
                return await aw

        if not self.asyncRequest.useScf:
            console.warning("[yellow]当前未使用云函数代理请求, 建议开启云函数功能对抗WAF等相关安全产品.[/yellow]")
        task_list = list()
        for fingerprint in env.fps:
            # 过滤器过滤不符合条件的指纹
            if fpFilter and not self.fingerFilter(fingerprint, availableFilters(fpFilter)):
                continue
            matches = fingerprint.asyncMatches(asyncRequestObj=self.asyncRequest,
                                               responseObj=response, mode=mode)
            if sys.version_info < (3, 7):
                task = asyncio.ensure_future(aw_task(matches))
            else:
                task = asyncio.create_task(aw_task(matches))
            task_list.append(task)
        result = await asyncio.gather(*task_list)
        return [match for match in result if match]

    def fingerFilter(self, fp: Fingerprint, fpFilter={}):
        filters = fp.filters
        if filters:
            for filterType, filterValue in filters.items():
                if not isinstance(filterValue, list):
                    filterValue = [filterValue]
                return [filterItem for filterItem in filterValue
                        if filterItem.lower() in [fpFilterValue.lower() for fpFilterValue in fpFilter.get(filterType)]]
        return False

    def _fingers(self) -> dict:
        return None

    def help(self):
        """
        显示用户自定义参数帮助信息

        :return:
        """
        console.info("{0} 模块参数帮助.".format(self.Name))
        options = self._options()
        if len(options) == 0:
            console.info("模块 {0} 暂无用户自定义参数信息.")
        console.debug("获取模块 {0} 用户自定义选项信息 {1}".format(self.Name, options.keys()))
        self.opt_parse = self.get_parse(options)
        console.print("")
        self.opt_parse.print_help()

    def get_parse(self, options):
        """
        根据模块用户自定义的选项信息生成 argparse.ArgumentParser 对象

        :param options: 模块用户自定义选项列表
        :return: argparse.ArgumentParser
        """
        opt_parse = argparse.ArgumentParser(prog=self.SPEC, conflict_handler='resolve', add_help=False,
                                            usage="ExpDepos -H host -M {0} [-p,--options] [Module Options]"
                                            .format(format_module(self.SPEC)))
        module_opt_group = opt_parse.add_argument_group("Module Options")
        for key in options.keys():
            args = {"help": options[key].description, "required": False if self.get_option(key.lower())
                    else options[key].require}
            if isinstance(options[key], OptBoolean):
                args.update({"action": "store_true"})   # 如果是OptBoolean则添加 action参数用于传入时候无须具体值的方式
            module_opt_group.add_argument("--" + key.lower(), **args)

        return opt_parse

    def parse_options(self, source):
        """
        解析模块必选参数

        :param source: 命令行提交的-P或者--options选项值
        :return: argparse 解析参数后的Namespace
        """
        # 当必选项大于0且用户为设置任何选项值的时候抛出错误
        if source is None and len(self.get_requireOpts()) > 0:
            raise ExploitValidationException("模块缺少必要参数 {0}. 请使用[bold cyan]-P[/bold cyan]"
                                             "或者[bold cyan]--options[/bold cyan]选项提供."
                                             .format(self.get_requireOpts()))
        if not self.opt_parse:
            self.opt_parse = self.get_parse(self._options())
        if source is not None:
            return self.opt_parse.parse_args(cli2args(source.split()))
        else:
            return None

    def get_options(self):
        """
        返回当前OPTIONS键值对应的列表

        :return: dic
        """
        return {key: val.value for key, val in self.OPTIONS.items()}

    def add_host(self, value):
        """
        添加HOST参数

        :param value: HOST 值
        :return:
        """
        self.OPTIONS.update({'host': OptHost(value, description="目标地址 (可选IP端口或URL地址)", require=True)})

    def set_option(self, key, value):
        """
        设置模块用户自定义参数值

        :param key: 用户自定义参数名
        :param value: 用户自定义参数值
        :return:
        """
        if key not in self.OPTIONS:
            raise ExploitAttribException("无法找到选项 {} 请确认该选项是否存在".format(key))
        self.OPTIONS[key].__set__("", value)

    def get_option(self, key):
        """
        返回模块用户自定义参数值

        :param key: 需要获取的参数名
        :return: 参数名对应值
        """
        if key.lower() not in self.OPTIONS:
            raise ExploitAttribException("无法找到选项 '{}' 请确认选项是否配置".format(key))
        return self.OPTIONS[key].value

    def get_requireOpts(self):
        """
        获取当前模块必选参数

        :return: list 必选参数列表
        """
        return [key.lower() for key in self._options().keys()
                if self.OPTIONS[key.lower()].require is True and not self.get_option(key.lower())]

    def get_allOpts(self):
        """
        获取当前模块所有自定义参数

        :return: list 所有自定义参数列表
        """
        return [key.lower() for key in self._options().keys()]

    def _options(self):
        """
        Exploit模块选项设置

        :return:
        """
        return dict()

    def _verify(self):
        """
        以exp的verify模式验证目标漏洞是否存

        :return:    Response
        """
        raise NotImplementedError("_verify")

    def _exploit(self):
        """
        以exp的exploit模式进行漏洞检测利用

        :return:    Response
        """
        raise NotImplementedError("_exploit")

    def _clean(self):
        """
        日志清理

        :return:    Response
        """
        pass

    async def aCloser(self):
        """
        关闭异步请求接口

        :return:
        """
        try:
            await self.asyncRequest.aclose()
        except RuntimeError as e:
            pass

    def scfInit(self, CloudFunctions):
        """
        初始化云函数

        :param CloudFunctions: 云函数配置信息
        :return:
        """
        configs = scfInit(CloudFunctions)
        self.request.scfCfg = self.asyncRequest.scfCfg = configs

    def run(self, options, mode="Verify"):
        """
        Exploit模块调用入口

        :param options: 命令行参数信息及模块参数信息
        :param mode: 利用模式(exploit)或者验证模式(verify)
        :return:
        """
        console.info("正在以 '{0}' 模式运行模块 '{1}'".format(mode, self.Name))
        self.result = Result(self)  # 初始化执行结果
        if 'host' in self.OPTIONS and not self.get_option("host") and self.OPTIONS['host'].require:
            self.result.fail("目标地址未设置.")
            raise ExploitValidationException("[red1]请设置目标地址(可选IP端口或URL地址)[/red1]")

        self.request = Request.instance(options)  # 初始化HTTP同步请求对象Request
        self.asyncRequest = Request.instance(options, isSync=True)  # 初始化HTTP异步请求对象asyncRequest
        if options.useScf:
            self.scfInit(env.Config.CloudFunctions)
        try:
            if mode.lower() == "verify":
                self._verify()
            else:
                self._exploit()
            self._clean()
        except NotImplementedError as e:
            console.error("模块实现错误,请编写必要功能方法: {0}".format(e.args[0]))
        finally:
            self.request.close()
            loop = None
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError as e:
                if "There is no current event loop in thread" in str(e):
                    loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            asyncio.get_event_loop().run_until_complete(self.aCloser())
