#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/8 16:22
"""

import asyncio
import traceback
import ExpDepos.libs.core.Request as Request
import ExpDepos.libs.core.Response as Response
from ExpDepos.libs.core.ModuleLoader import ModuleLoader
from ExpDepos.libs.core.base.ModuleBase import *
from ExpDepos.libs.core.base.ExceptionBase import *
from ExpDepos.libs.core.base.PayloadBase import PayloadBase
from ExpDepos.libs.core.common.Result import Result
from ExpDepos.libs.core.base.Fingerprint import Fingerprint, register, instanceFingerprint, availableFilters, \
    get_all_file, loadFromFile


class ExploitBase(ModuleBase):
    """
    Exp基类，用于定义每个exp默认方法及规则
    """

    def __init__(self):
        super(ExploitBase, self).__init__()
        # 初始化 host 参数 防止与用户自定义参数冲突
        self.OPTIONS.update({'host': OptString("", description="目标地址 (可选IP端口或URL地址)", require=False)})
        self.OPTIONS.update({'payload': OptPayload("", description="Exploit模块有效攻击载荷", require=False)})
        self.result = None  # 模块执行结果
        self.request = None  # HTTP同步请求接口
        self.asyncRequest = None  # HTTP异步请求接口
        # self._init_fingerprint() # 在ModuleLoader中完成对象实例化并设置SPEC之后再调用

    @property
    def fingerprint(self) -> any:
        """
        识别目标指纹信息

        :return:    指纹信息实例
        """
        fp = None
        try:
            fp = self._get_fp_info()
        except NotImplementedError:
            console.warning("[green]{0}[/green] 未实现指纹识别功能, 请重载[magenta3]_fingers()[/magenta3]方法."
                            .format(self.Name))
            return None
        if fp:
            self._register_fp(fp)
            return instanceFingerprint(fp)
        return None

    def init_fingerprint(self):
        """
        在模块加载时候初始化并注册指纹信息

        :return:
        :rtype:
        """
        fp = None
        try:
            fp = self._get_fp_info()
        except NotImplementedError:
            return
        except ExpDeposFingerprintException as e:
            raise ExpDeposFingerprintException(e.args[0])
        except Exception as e:
            raise ExpDeposFingerprintException(f"尝试获取 [bold green]{self.Name}[/bold green] 模块指纹信息失败: {e.args[0]}")
        if fp:
            self._register_fp(fp)
            return instanceFingerprint(fp)
        return None

    def _get_fp_info(self):
        """
        获取指纹信息

        :return: 指纹信息
        :rtype: dict
        """
        fp = self._fingers()
        if isinstance(fp, str) or isinstance(fp, tuple):
            fp = self._load_fp_from_file(fp)
            if not fp:
                raise ExpDeposFingerprintException(f"无法获取指纹信息, 请确认提供的指纹文件名是否正确!")
        return fp

    def _register_fp(self, fp: dict):
        """
        注册指纹信息到指纹库

        :param fp: 指纹信息
        :type fp: dict
        :return:
        :rtype:
        """
        if not fp:
            return None
        fp.update({"regByExp": self.SPEC})  # 将指纹与当前模块SPEC绑定
        return register(fp)

    def _load_fp_from_file(self, fp: [str, tuple]):
        """
        从文件加载已有的指纹信息

        :param fp: 指纹信息
        :type fp: [str, tuple]
        :return:
        :rtype:
        """
        file_name = exp_fingerprint = ''
        if isinstance(fp, tuple):
            try:
                file_name, exp_fingerprint = fp
            except Exception as e:
                raise ExpDeposFingerprintException(f"模块 [bold green]{self.Name}[/bold green] 指纹信息错误: {fp}")
        if isinstance(fp, str):
            file_name = fp
        fp_file = self._get_fp_file(file_name)
        if fp_file:
            fingerprint = loadFromFile(fp_file)
            if fingerprint and exp_fingerprint:
                self._merge_matches(fingerprint, exp_fingerprint)
            return fingerprint
        return None

    def _merge_matches(self, fingerprint, exp_fingerprint):
        """
        合并指纹

        :param fingerprint: 现有的指纹信息
        :type fingerprint: dict
        :param exp_fingerprint: 用户自定义的指纹信息
        :type exp_fingerprint: dict
        :return: 合并后的指纹信息
        :rtype: dict
        """
        if not exp_fingerprint:
            return
        if not isinstance(exp_fingerprint, dict):
            raise ExpDeposFingerprintException(f"模块 [bold green]{self.Name}[/bold green] 指纹格式错误, "
                                               f"应为 [bold yellow]dict[/bold yellow] 类型!")
        for key, val in exp_fingerprint.items():
            if key in fingerprint:
                if isinstance(val, str):
                    fingerprint[key] = val
                    continue
                if isinstance(val, list) and isinstance(fingerprint[key], list):
                    fingerprint[key].extend(val)
                    continue
                if isinstance(val, dict) and isinstance(fingerprint[key], dict):
                    self._merge_matches(fingerprint[key], val)
                    continue
            fingerprint[key] = val

    @staticmethod
    def _get_fp_file(file_name):
        """
        从所有指纹文件中获取包含file_name的文件名

        :param file_name: 匹配到到文件名
        :type file_name: str
        :return:
        :rtype:
        """
        if not file_name:
            return None
        file_name = file_name + ".yaml"
        all_fp_files = get_all_file(env.Config.FINGER_PATH)
        for file in all_fp_files:
            if file_name in file:
                return file
        return None

    def _options(self):
        return super()._options()

    @property
    def payload(self) -> PayloadBase:
        """
        payload 信息

        :return:
        """
        try:
            payload = self.get_option("payload")
        except ExploitAttribException as e:
            raise ExploitValidationException(repr(e))
        if not payload:
            raise ExploitValidationException("模块 {0} 需要配置有效攻击载荷.".format(self.Name))
        return self.getPayload(payload)

    def getPayload(self, payload) -> PayloadBase:
        """
        从已加载的模块中获取payload模块

        :param payload:
        :return:
        """
        payload_info = ModuleLoader.get_loaded_module(payload)
        if not payload_info:
            raise ExploitValidationException("无效的payload: {0}".format(payload))
        return payload_info["module"]

    def payloadInit(self, options):
        """
        payload初始化

        :param options: payload参数信息
        :return:
        """
        # 设置Payload
        payload_info = ModuleLoader.get_loaded_module(options.payload)
        if not payload_info:
            raise ExploitValidationException("无效的payload: {0}".format(options.payload))
        console.info("为模块 [bright_magenta]{0}[/bright_magenta] 应用攻击载荷: [bold yellow]{1}[/bold yellow]"
                     .format(self.Name, payload_info["Name"]))
        self.add_payload(payload_info["Alias"])  # 添加payload
        payload_obj = payload_info["module"]
        if options.payload_opts:
            payload_options = payload_obj.parse_options(options.payload_opts)
            if payload_options:
                console.debug("解析到Payload参数：{0}".format(payload_options))
            else:
                raise ExpDeposExploitException("Payload 参数解析失败: {0}".format(options.payload_opts))
            ModuleLoader.set_module_opts(payload_obj, payload_options)
        # 设置Encoder
        if options.encode:
            encode_info = ModuleLoader.get_loaded_module(options.encode)
            if not encode_info:
                raise ExploitValidationException("无效的encoder: {0}".format(options.encode))
            payload_obj.add_encoder(encode_info['Alias'])
            encode_obj = encode_info["module"]
            if options.encode_opts:
                encode_options = encode_obj.parse_options(options.encode_opts)
                if encode_options:
                    console.debug("解析到Encoder参数: {0}".format(encode_options))
                else:
                    raise ExpDeposExploitException("Encoder 参数解析失败: {0}".format(options.payload_opts))
                ModuleLoader.set_module_opts(encode_obj, encode_options)

    def fpMatches(self, response: Response, mode="ALL", host="", fp_filter={}, progress=None) -> list:
        """
        指纹识别

        :param response: Response 对象
        :param mode: 识别模式 可选ALL、PASS, AGGR, EXP
        :@param host: 指定特定的host
        :param fp_filter: 指纹过滤器 用于过滤包含指定过滤器的指纹
        :@param progress: 进度条对象
        :return: list
        """
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_until_complete(self.asyncFpMatches(response=response,
                                                                               mode=mode,
                                                                               host=host,
                                                                               fp_filter=fp_filter,
                                                                               progress=progress))

    async def asyncFpMatches(self, response: Response, mode="ALL", host="", fp_filter={}, progress=None) -> list:
        """
        并发指纹识别

        :param response: Response 对象
        :param mode: 识别模式 可选ALL、PASS, AGGR, EXP
        :@param host: 指定特定的host
        :param fp_filter: 指纹过滤器 用于过滤包含指定过滤条件的指纹
        :@param progress: 进度条对象
        :return: list
        """
        sem = asyncio.Semaphore(env.CliOptions.thread)

        async def aw_task(aw):
            async with sem:
                return await aw

        # if not self.asyncRequest.useScf:
        #     console.warning("[yellow]当前未使用云函数代理请求, 建议开启云函数功能对抗WAF等相关安全产品.[/yellow]")
        task_list = list()
        request = Request.instance(env.CliOptions, isSync=True)  # 新建request对象，兼容在子线程中调用
        if progress:
            request.set_progress(progress)
        for fingerprint in env.fps:
            # 过滤器过滤不符合条件的指纹
            if fp_filter and not self.fingerFilter(fingerprint, availableFilters(fp_filter)):
                continue
            matches = fingerprint.asyncMatches(asyncRequestObj=request,
                                               responseObj=response, mode=mode, host=host)
            if sys.version_info < (3, 7):
                task = asyncio.ensure_future(aw_task(matches))
            else:
                task = asyncio.create_task(aw_task(matches))
            task_list.append(task)
        result = await asyncio.gather(*task_list)
        return [match for match in result if match["matches"]]

    def fingerFilter(self, fp: Fingerprint, fp_filter={}):
        """
        根据指纹过滤器过滤指纹

        @param fp: 指纹对象
        @type fp: Fingerprint
        @param fp_filter: 用户自定义的过滤信息
        @type fp_filter: dict
        @return: 该指纹是否满足过滤条件
        @rtype: boolean
        """
        for fileter_type, fileter_values in fp_filter.items():
            if fileter_type == 'type' and not self.match_type_fileter(fp, fp_filter):
                return False
            if fileter_type in fp.filters:
                match_values = fp.filters.get(fileter_type)
                if not isinstance(match_values, list):
                    match_values = [match_values]
                is_match_fileter = [fileter_value for fileter_value in fileter_values
                                    if fileter_value.lower() in [match_value.lower() for match_value in match_values]]
                if not is_match_fileter:
                    return False
        return True

    def match_type_fileter(self, fp: Fingerprint, fp_fileter):
        """
        根据指纹类型过滤指纹

        @param fp: 指纹对象
        @type fp: Fingerprint
        @param fp_fileter: 用户自定义的过滤信息
        @type fp_fileter: dict
        @return: 该指纹是否满足过滤条件
        @rtype: boolean
        """
        if "type" not in fp_fileter:
            return False
        matches = fp_fileter.get("type")
        if not isinstance(matches, list):
            matches = [matches]
        match_list = [value for value in [match_value.lower() for match_value in matches]]
        if isinstance(fp.type, list):
            return self._match_type_by_list(fp.type, match_list)
        return fp.type.lower() in match_list

    def _match_type_by_list(self, fp_type_list: list, match_list: list):
        """
        指纹类型列表匹配，用于支持指纹类型为列表的过滤属性

        :param fp_type_list: 指纹类型列表
        :type fp_type_list: list
        :param match_list: 匹配列表
        :type match_list: list
        :return:
        :rtype:
        """
        if not fp_type_list or not match_list:
            return False
        for fp_type in fp_type_list:
            if fp_type.lower() in match_list:
                return True
        return False

    def _fingers(self) -> [dict, str, tuple]:
        return None

    def add_host(self, value):
        """
        添加HOST参数

        :param value: HOST 值
        :return:
        """
        self.OPTIONS.update({'host': OptHost(value, description="目标地址 (可选IP端口或URL地址)", require=True)})

    def add_payload(self, value):
        """
        添加payload

        :param value: payload 别名或是路径信息
        :return:
        """
        self.OPTIONS.update({'payload': OptString(value, description="使用的攻击载荷", require=True)})

    def _init(self) -> bool:
        """
        在模块运行前先调用的初始化函数

        :return:
        :rtype: bool
        """
        pass

    def _verify(self):
        """
        以exp的verify模式验证目标漏洞是否存

        :return:    Response
        """
        raise NotImplementedError("_verify")

    def _exploit(self):
        """
        以exp的exploit模式进行漏洞检测利用

        :return:    Response
        """
        raise NotImplementedError("_exploit")

    def _clean(self):
        """
        日志清理

        :return:    Response
        """
        pass

    async def aCloser(self):
        """
        关闭异步请求接口

        :return:
        """
        try:
            await self.asyncRequest.aclose()
        except RuntimeError as e:
            pass

    def scfInit(self, CloudFunctions):
        """
        初始化云函数

        :param CloudFunctions: 云函数配置信息
        :return:
        """
        configs = scfInit(CloudFunctions)
        self.request.scfCfg = self.asyncRequest.scfCfg = configs

    def run(self, options, mode="Verify"):
        """
        Exploit模块调用入口

        :param options: 命令行参数信息及模块参数信息
        :param mode: 利用模式(exploit)或者验证模式(verify)
        :return:
        """
        console.info("正在以 [green]{0}[/green] 模式运行模块 [bright_magenta]{1}[/bright_magenta]"
                     .format(mode, self.Name))
        self.result = Result(self)  # 初始化执行结果
        if 'host' in self.OPTIONS and not self.get_option("host") and self.OPTIONS['host'].require:
            self.result.fail("目标地址未设置.")
            raise ExploitValidationException("[red1]请设置目标地址(可选IP端口或URL地址)[/red1]")

        self.request = Request.instance(options)  # 初始化HTTP同步请求对象Request
        self.asyncRequest = Request.instance(options, isSync=True)  # 初始化HTTP异步请求对象asyncRequest
        # 设置payload
        if options.payload:
            self.payloadInit(options)
        if options.useScf:
            try:
                self.scfInit(env.Config.CloudFunctions)
            except AttributeError as e:
                if "CloudFunctions" in repr(e):
                    raise ExploitValidationException(f"[red]CloudFunctions[/red] 未配置! 请先在config中配置云函数参数! ")
            except Exception as e:
                raise ExploitValidationException(repr(e))
        try:
            self._init()  # 运行前先运行init函数
            if mode.lower() == "verify":
                self._verify()
            else:
                self._exploit()
            self._clean()
        except KeyboardInterrupt:
            # console.warning(f"已手动终止运行 {self.Name}")
            self.result.fail(f"已手动终止运行 [bold yellow]{self.Name}[/bold yellow]")
        except NotImplementedError as e:
            console.error("模块实现错误,请编写必要功能方法: {0}".format(e.args[0]))
        finally:
            self.request.close()
            loop = None
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError as e:
                if "There is no current event loop in thread" in str(e):
                    loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            asyncio.get_event_loop().run_until_complete(self.aCloser())
