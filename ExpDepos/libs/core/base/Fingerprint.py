#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/10 10:44
"""

import os
import re
import json
import yaml
import string
import random
import asyncio
import hashlib

from collections.abc import Iterable
from rich.progress import Progress
from ExpDepos.libs.core.Response import Response
from ExpDepos.libs.core.common.Common import env, console, randstr
from ExpDepos.libs.core.common.Console import formatPgString
from ExpDepos.libs.core.common.Enums import FINGERPRINT, ENUMS
from ExpDepos.libs.core.base.ExceptionBase import ExpDeposFingerprintException

ALLOW_SETS = FINGERPRINT.ALLOW_SETS
ALLOW_LOGICS = FINGERPRINT.ALLOW_LOGICS
ALLOW_MATCHES_ITEM = FINGERPRINT.ALLOW_MATCHES_ITEM
ALLOW_MATCHES_SEARCH_ITEM = FINGERPRINT.ALLOW_MATCHES_SEARCH_ITEM
ALLOW_MATCHES_VALUE_TYPE = FINGERPRINT.ALLOW_MATCHES_VALUE_TYPE
ALLOW_MATCHES_VALUE_ATTR = FINGERPRINT.ALLOW_MATCHES_VALUE_ATTR
ALLOW_FILTERS_ITEM = {"platform": ENUMS.PLATFORM,
                      "middleware": ENUMS.MIDDLEWARE,
                      "language": ENUMS.SCRIPT_LANGUAGE,
                      "type": [
                          FINGERPRINT.FP_TYPE.WEBAPP.lower(),
                          FINGERPRINT.FP_TYPE.MIDDLEWARE.lower(),
                          FINGERPRINT.FP_TYPE.PLATFORM.lower(),
                          FINGERPRINT.FP_TYPE.NET_DEVICE.lower(),
                          FINGERPRINT.FP_TYPE.SEC_DEVICE.lower(), 'example']
                      }
LOGIC_AND_SYMBOL = '<&&>'
LOGIC_OR_SYMBOL = '<||>'


def dump(fp):
    """
    将指纹信息转换成YAML格式

    :param fp: 指纹信息
    :return: str
    """
    return yaml.dump(fp)


def register(fp: dict):
    """
    注册指纹信息

    :param fp: 指纹信息
    :return:
    """
    fileName = formatFileName(fp["name"]) if 'fileName' not in fp else fp.pop('fileName')
    filePath = env.Config.FINGER_PATH + os.sep + fileName + ".yaml"
    loadFp = loadFromFile(fileName)
    fpDump = dump(fp)
    if not loadFp or loadFp != yaml.load(fpDump, Loader=yaml.SafeLoader):
        with open(filePath, "w", encoding="UTF-8") as fpFile:
            return fpFile.write(fpDump)
    return False


def getFpFilePath(fileName: str):
    """
    获取指纹信息文件绝对路径

    :param fileName: 指纹文件名
    :return:
    """
    return env.Config.FINGER_PATH + os.sep + fileName + (".yaml" if not fileName.endswith(".yaml") else '')


def loadFromFile(fileName: str):
    """
    从YAML文件中加载指纹信息

    :param fileName: 指纹名称或文件名
    :return:
    """
    fileName = formatFileName(fileName)
    filePath = getFpFilePath(fileName)
    try:
        return yaml.load(open(filePath, "rb"), Loader=yaml.SafeLoader)
    except FileNotFoundError:
        return None


def setCache(configList):
    """
    写入缓存

    :param configList: 指纹配置信息列表
    :return:
    """
    cacheDir = env.Config.DATA_PATH + os.sep + 'fingerprint'
    if not os.path.exists(cacheDir):
        os.makedirs(cacheDir)
    filePath = cacheDir + os.sep + 'fpConfigs.json'
    with open(filePath, "w", encoding="UTF-8") as cacheFile:
        return cacheFile.write(json.dumps(configList))


def getCache():
    """
    从缓存文件中获取指纹信息列表

    :return: list
    """
    cacheDir = env.Config.DATA_PATH + os.sep + 'fingerprint'
    filePath = cacheDir + os.sep + 'fpConfigs.json'
    if os.path.exists(filePath):
        with open(filePath, "r", encoding="UTF-8") as cacheFile:
            return json.loads(cacheFile.read())
    return None


def getCacheOfFile(filename, caches):
    """
    根据文件名从缓存列表中获取指纹信息

    :param filename: 文件名
    :param caches: 缓存列表
    :return:
    """
    if caches:
        for cache in caches:
            if filename in cache and cache[filename]:
                return cache
    return None


def fileHash(file):
    """
    计算文件hash值

    :param file: 文件名
    :return:
    """
    filePath = getFpFilePath(file)
    with open(filePath, "rb") as file:
        return hashlib.md5(file.read()).hexdigest()


def loadFingerprints() -> list:
    """
    加载所有指纹信息

    :return: list
    """
    fpList = []
    filePath = env.Config.FINGER_PATH
    fileList = os.listdir(filePath)
    configList = []
    cacheFp = getCache()
    if not cacheFp:
        console.debug("[red]can't load cacheFp from cache file.[/red]")
    with Progress() as progress:
        task = progress.add_task(formatPgString("[green]正在初始化指纹库...[/green]"), total=len(fileList))
        for file in fileList:
            file_hash = fileHash(file)
            fileCache = getCacheOfFile(file, cacheFp)
            if fileCache and file_hash == fileCache[file]["hash"]:
                fpConfig = fileCache[file]["config"]
            else:
                fpConfig = loadFromFile(file)
            if fpConfig:
                configList.append({file: {"hash": fileHash(file), "config": fpConfig}})
                fpList.append(instanceFingerprint(fpConfig))
            progress.update(task, advance=1)
    setCache(configList)
    return fpList


def formatFileName(fpName):
    """
    格式化文件名

    :param fpName: 指纹名称
    :return: str
    """
    return fpName.replace(" ", "_").replace(":", "_")


def availableSets(sets: dict) -> dict:
    """
    校验参数设置合法性

    :param sets: 参数设置信息
    :return: dict
    """
    for setItem in sets.keys():
        if setItem.lower() not in ALLOW_SETS:
            raise ExpDeposFingerprintException("未被允许的参数设置项：[yellow]{0}[yellow]"
                                               " 只允许[green]{1}[/green]".format(setItem, ALLOW_SETS))
    return sets


def availableMatchLogic(logic):
    """
    校验匹配逻辑

    :param logic: 逻辑字符串
    :return: str
    """
    if logic.lower() not in ALLOW_LOGICS:
        raise ExpDeposFingerprintException("错误的匹配逻辑 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                           .format(logic, ALLOW_LOGICS))
    return logic


def availableSearchItems(searchItem: str):
    """
    校验匹配范围的合法性

    :param searchItem:
    :return: str
    """
    if searchItem.lower() not in ALLOW_MATCHES_SEARCH_ITEM \
            and not availableSpecificHeader(searchItem):
        raise ExpDeposFingerprintException("错误的匹配项 [yellow]{0}[/yellow]."
                                           " 只允许: [green]{1}[/green]".format(searchItem, ALLOW_MATCHES_SEARCH_ITEM))
    return searchItem


def availableSpecificHeader(searchItem: str):
    return re.match(r"headers\[([\w-]+)\]", searchItem)


def availableFilters(filters: dict):
    """
    校验过滤器合法性

    :param filters: 过滤器信息
    :return: dict
    """
    for filterItem in filters.keys():
        if filterItem.lower() not in ALLOW_FILTERS_ITEM.keys():
            raise ExpDeposFingerprintException("错误的过滤项 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                               .format(filterItem, ALLOW_FILTERS_ITEM.keys()))
        if not isinstance(filters[filterItem], list):
            filters[filterItem] = [filters[filterItem]]
        for filterValue in filters[filterItem]:
            if filterValue.lower() not in ALLOW_FILTERS_ITEM[filterItem]:
                raise ExpDeposFingerprintException("错误的过滤值 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                                   .format(filterValue, ALLOW_FILTERS_ITEM[filterItem]))
    return filters


def instanceMatches(matches: list) -> list:
    """
    实例指纹匹配对象

    :param matches: 指纹匹配项列表
    :return: list
    """
    return [FpMatches(matchesItem) for matchesItem in matches]


def instanceFingerprint(fp: dict):
    if "name" not in fp and not fp["name"]:
        raise ExpDeposFingerprintException("未命名的指纹配置信息.")
    author = fp['author'] if 'author' in fp and fp['author'] else 'Anonymous'
    version = fp['version'] if 'version' in fp and fp['version'] else None
    fpType = fp["type"] if 'type' in fp and fp["type"] else FINGERPRINT.FP_TYPE.WEBAPP
    sets = fp['sets'] if 'sets' in fp and fp['sets'] else None
    description = fp["description"] if 'description' in fp and fp["description"] else None
    website = fp["website"] if 'website' in fp and fp["website"] else None
    filters = fp["filters"] if 'filters' in fp and fp["filters"] else None
    logic = fp["logic"] if 'logic' in fp and fp["logic"] else 'or'
    regByExp = fp["regByExp"] if 'regByExp' in fp and fp["regByExp"] else False
    file_path = fp["file_path"] if "file_path" in fp and fp["file_path"] else None
    return Fingerprint(name=fp["name"],
                       author=author,
                       version=version,
                       fpType=fpType,
                       sets=sets,
                       description=description,
                       website=website,
                       filters=filters,
                       matches=fp["matches"],
                       matchLogic=logic,
                       regByExp=regByExp,
                       file_path=file_path)


def isRandom(strObj: str) -> any:
    """
    验证是否使用随机数生成器

    :param strObj: 含有 {randstr()}标识的字符串
    :return: bool
    """
    return re.search(r"(\{randstr\((?:length=)?((?:\d){1,2})?,?\s?(?:number=)?(True|true|False|false)?\)\})", strObj)


def getRandArgs(strObj: str):
    """
    获取randstr函数的参数值

    :param strObj: 含有 {randstr()}标识的字符串
    :return:
    """
    match = re.search(r"\{randstr\((?:length=)?((?:\d){1,2})?,\s??(?:number=)?(True|true|False|false)?\)\}", strObj)
    try:
        length = int(match.group(1))
    except AttributeError:
        length = 5
    except TypeError:
        length = 5
    try:
        number = True if match.group(2).lower() == 'true' else False
    except AttributeError:
        number = False
    return length, number


def makeRandstr(objs):
    """
    生成随字符串

    :param objs: 含有 {randstr()}标识的字典、列表、字符串对象
    :return:
    """
    if isinstance(objs, Iterable):
        if isinstance(objs, dict):
            for key, value in objs.items():
                key = makeRandstr(key)
                value = makeRandstr(value)
                objs.update({key: value})
            return objs
        if isinstance(objs, list):
            for value in objs:
                objs[objs.index(value)] = makeRandstr(value)
            return objs
    israndom = isRandom(objs)
    if israndom:
        length, number = getRandArgs(objs)
        objs = objs.replace(israndom.group(1), randstr(length, number))
    return objs


def assign_host(fp_url: str, host):
    """
    指定host请求

    @param fp_url: 指纹请求地址
    @type fp_url: str
    @param host: 指定的主机地址
    @type host: str
    @return:
    @rtype:
    """
    if not host or host == '':
        return fp_url
    if not host.startswith("http"):
        host = f"http://{host}"
    if not fp_url.startswith("/"):
        fp_url = f"/{fp_url}"
    return host + fp_url


class FpMatches(object):
    """
    指纹匹配项
    """

    def __init__(self, matchesItem: dict):
        matchesItemKeys = list(matchesItem.keys())
        self._matchesItem = "text"  # 默认匹配项目为response.text
        self._requestUrl = None
        self._certainty = None
        self._isAggressive = False
        self._aim = None
        self._name = None
        self._offset = None
        if 'name' in matchesItem:
            self._name = matchesItem['name']
        if 'url' in matchesItem:
            self._isAggressive = True  # 包含了url项则该指纹匹配项为主动式匹配
            self._requestUrl = matchesItem["url"]
            if 'status' not in matchesItem:
                matchesItem.update({"status": 200})  # 主动匹配默认要求URL状态为200
        if 'search' in matchesItem:
            self._matchesItem = availableSearchItems(matchesItem["search"])
        if 'certainty' in matchesItem:
            self._certainty = matchesItem['certainty']
        if 'offset' in matchesItem:
            self._offset = matchesItem['offset']
        if 'aim' in matchesItem:
            self._aim = matchesItem['aim']
        if 'status' in matchesItem:
            self._matchesItem = 'http'
        self._specificHeader = availableSpecificHeader(self._matchesItem)
        self._matchesItemType = self.getMatchesItemType(matchesItemKeys)
        self._matchesItemValue = matchesItem

    @property
    def name(self):
        return self._name

    @property
    def isAggressive(self):
        return self._isAggressive

    @property
    def matchesItem(self):
        return self._matchesItem

    @property
    def matchesItemType(self):
        return self._matchesItemType

    @property
    def matchesItemValue(self):
        return self._matchesItemValue

    @property
    def specificHeader(self):
        return self._specificHeader

    @property
    def requestUrl(self):
        return self._requestUrl

    @property
    def certainty(self):
        return self._certainty

    @property
    def offset(self):
        return self._offset

    @property
    def aim(self):
        return self._aim

    @staticmethod
    def getMatchesItemType(matchesItemKeys):
        """
        获取匹配方式

        :param matchesItemKeys: 指纹配置字典的键值列表
        :return:
        """
        ckList = [itemKey for itemKey in matchesItemKeys if itemKey in ALLOW_MATCHES_VALUE_TYPE]
        if not ckList:
            raise ExpDeposFingerprintException("指纹配置错误!未找到任何可识别的匹配方式.")
        return ckList


class Fingerprint(object):
    """
    指纹识别
    """

    def __init__(self, name: str,
                 version: str,
                 author: list,
                 matches: list,
                 matchLogic: str = "or",
                 description: str = "",
                 website: str = "",
                 fpType: str = FINGERPRINT.FP_TYPE.WEBAPP,
                 sets: dict = {},
                 filters: dict = {},
                 regByExp: bool = False,
                 file_path=None):
        self._Name = name
        self._Version = version
        self._Author = author
        self._Matches = instanceMatches(matches)
        self._MatchLogic = availableMatchLogic(matchLogic)
        self._description = description
        self._website = website
        self._Sets = availableSets(sets) if sets is not None else {}
        self._Filters = availableFilters(filters) if filters is not None else {}
        self._type = fpType
        self._regByExp = regByExp
        self._file_path = file_path
        self._source_matches = matches
        pass

    @property
    def name(self):
        return self._Name

    @property
    def version(self):
        return self._Version

    @property
    def author(self):
        return self._Author

    @property
    def matches(self):
        return self._Matches

    @property
    def matchLogic(self):
        return self._MatchLogic

    @property
    def description(self):
        return self._description

    @property
    def website(self):
        return self._website

    @property
    def sets(self):
        return self._Sets

    @property
    def filters(self):
        return self._Filters

    @property
    def type(self):
        return self._type

    @property
    def regByExp(self):
        return self._regByExp

    @property
    def file_path(self):
        return self._file_path

    @property
    def source_matches(self):
        return self._source_matches

    def getSets(self):
        """
        获取HTTP 请求设置

        :return:
        """
        if self.sets:
            headers = cookies = data = params = None
            if 'headers' in self.sets and self.sets['headers']:
                headers = self.sets['headers']
                if not isinstance(headers, dict):
                    raise ExpDeposFingerprintException("设置的[green]Headers[/green]参数应为键值对应的字典格式.")
            if 'cookies' in self.sets and self.sets["cookies"]:
                cookies = self.sets["cookies"]
                if not isinstance(cookies, dict):
                    raise ExpDeposFingerprintException("设置的[green]Cookies[/green]参数应为键值对应的字典格式.")
            if 'data' in self.sets:
                data = self.sets["data"]
            if 'params' in self.sets and self.sets["params"]:
                params = self.sets["params"]
                if not isinstance(params, dict):
                    raise ExpDeposFingerprintException("设置的[green]GET[/green]参数应为键值对应的字典格式.")
            return makeRandstr(headers), makeRandstr(cookies), makeRandstr(data), makeRandstr(params)
        return None, None, None, None

    def todict(self):
        return {
            "name": self.name,
            "author": self.author,
            "version": self.version,
            "type": self.type,
            "logic": self.matchLogic,
            "description": self.description,
            "website": self.website,
            "filters": self.filters,
            "matches": self.source_matches,
            "sets": self.sets,
            "file_path": self.file_path
        }

    def aggressiveMatches(self, request, matchesObj: FpMatches):
        """
        主动式匹配

        :param request: request对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        method = "GET"
        headers, cookies, data, params = self.getSets()
        if data or data == '':
            method = "POST"
        response = request.request(method=method,
                                   url=makeRandstr(matchesObj.requestUrl),
                                   headers=headers,
                                   cookies=cookies,
                                   data=data,
                                   params=params,
                                   allow_redirects=False)
        return self.passiveMatches(response=response, matchesObj=matchesObj)

    async def asyncAggressiveMatches(self, asyncRequest, matchesObj: FpMatches, host=''):
        """
        并发主动式匹配

        :param asyncRequest: AsyncRequest对象
        :param matchesObj: 需要匹配的FpMatches对象
        :@param host: 指定特定的host
        :return:
        """
        method = "GET"
        headers, cookies, data, params = self.getSets()
        if data or data == '':
            method = "POST"
        response = await asyncRequest.request(method=method,
                                              url=assign_host(makeRandstr(matchesObj.requestUrl), host=host),
                                              headers=headers,
                                              cookies=cookies,
                                              data=data,
                                              params=params,
                                              allow_redirects=False)
        if not response:
            return None
        if response.status_code != matchesObj.matchesItemValue['status']:
            return None  # 主动匹配如果response.status_code不匹配则后续不用再继续匹配
        return await self.passiveMatches(response=response, matchesObj=matchesObj)

    async def passiveMatches(self, response: Response, matchesObj: FpMatches):
        """
        被动匹配

        :param response: http response对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        matched = []
        # 每一个匹配规则都有一个或者多个匹配方式
        # 这些匹配方式需要全部满足该匹配规则才算匹配成功
        for matchesItemType in matchesObj.matchesItemType:
            position = 'body'
            if matchesObj.matchesItem == "headers":
                position = "headers"
            if matchesObj.specificHeader:
                position = f"header[{matchesObj.specificHeader.group(1)}]"
            match = await self.match(response=response, matchesObj=matchesObj, matchesItemType=matchesItemType)
            if not match:
                return None
            matched.extend([{matchesItemType: match,
                             "pattern": matchesObj.matchesItemValue[matchesItemType],
                             "position": position}])
        if matched:
            matchResult = {"name": self.name + '.' + matchesObj.name if matchesObj.name else self.name,
                           "matchMod": "aggressive" if matchesObj.isAggressive else "passive",
                           "matchType": matchesObj.matchesItemType}
            if self.regByExp:
                matchResult.update({"regByExp": self.regByExp})
            if matchesObj.certainty:
                matchResult.update({"certainty": matchesObj.certainty})
            if matchesObj.requestUrl:
                matchResult.update({"matchUrl": matchesObj.requestUrl})
            if matchesObj.aim:
                aimValue = matchesObj.matchesItemValue[matchesObj.aim] \
                    if matchesObj.aim in matchesObj.matchesItemValue else matched
                matchResult.update({"aim": matchesObj.aim, matchesObj.aim: aimValue})
            matchResult.update({"matched": matched})
            return matchResult
        return None

    async def asyncPassiveMatches(self, response: Response, matchesObj: FpMatches):
        """
        并发被动匹配

        :param response: http response对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        return await self.passiveMatches(response=response, matchesObj=matchesObj)

    async def match(self, response, matchesObj, matchesItemType):
        """
        匹配规则

        :param response: Response对象
        :param matchesObj: FpMatches 对象
        :param matchesItemType: 匹配方式
        :return:
        """
        if matchesItemType == "status":
            if response.status_code == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesItemType == "hash":
            if isinstance(matchesObj.matchesItemValue[matchesItemType], list):
                match = await self.matchList(response.hash, matchesObj.matchesItemValue[matchesItemType])
                if match:
                    return match
            if response.hash == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesItemType == "md5":
            if isinstance(matchesObj.matchesItemValue[matchesItemType], list):
                match = await self.matchList(response.md5sum, matchesObj.matchesItemValue[matchesItemType])
                if match:
                    return match
            if response.md5sum == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesObj.matchesItem == "headers" or matchesObj.specificHeader:
            return await self.matchHeaders(response.headers, matchesObj, matchesItemType)
        return await self.matchValues(matchSource=response.text, matchesObj=matchesObj, matchesItemType=matchesItemType)

    async def matchList(self, match_value, match_list):
        """
        列表匹配

        :param match_value:
        :type match_value:
        :param match_list:
        :type match_list:
        :return:
        :rtype:
        """
        if match_value in match_list:
            return match_list[match_list.index(match_value)]
        return False

    async def matchValues(self, matchSource, matchesObj, matchesItemType):
        """
        内容匹配

        :param matchSource: 匹配数据源
        :param matchesObj: FpMatches对象
        :param matchesItemType: 匹配方式
        :return:
        """
        if matchesItemType == "keyword":
            return await self.matchKeywords(matchSource, matchesObj.matchesItemValue[matchesItemType])
        if matchesItemType == "regex":
            matches = await self.regexMatch(matchSource, matchesObj.matchesItemValue[matchesItemType])
            if matches:
                return matches.group(matchesObj.offset) if matchesObj.offset else matches

    @staticmethod
    async def containsMatch(source: str, keyword: str):
        """
        关键词包含匹配

        :param source: 匹配数据源
        :param keyword: 关键词
        :return:
        """
        if keyword in source:
            return keyword
        return None

    @staticmethod
    async def splitLonStr(source: str) -> list:
        """
        分割过长的行为多行，防止正则回溯耗时太长

        :param source:
        :return:
        """
        splitStr = source.split("\n")
        rebuild = list()
        for line in splitStr:
            if len(line) > 1000:
                rebuild.extend([line[i:i + 1000] for i in range(0, len(line), 1000)])
                continue
            rebuild.append(line)
        return rebuild

    @staticmethod
    async def regexMatch(source, regex):
        """
        正则匹配

        :param source: 匹配数据源
        :param regex: 正则表达式
        :return:
        """
        source_list = await Fingerprint.splitLonStr(source)
        compiled_pattern = re.compile(rf"{regex}", re.DOTALL)
        for source in source_list:
            # match = re.search(regex, source)
            match = compiled_pattern.search(source)
            if match:
                return match
        return None

    async def matchKeywords(self, matchSource, matchValue):
        """
        关键词匹配

        :param matchSource: 匹配数据源
        :param matchValue: 需要匹配的关键词
        :return:
        """
        if isinstance(matchValue, str) and (LOGIC_AND_SYMBOL in matchValue or LOGIC_OR_SYMBOL in matchValue):
            # 多关键词逻辑匹配
            return await self.multiKeywordsMatch(matchSource=matchSource, matchValue=matchValue)
        if not isinstance(matchValue, str):
            matchValue = str(matchValue)
        return await self.containsMatch(matchSource, matchValue)

    async def multiKeywordsMatch(self, matchSource, matchValue: str):
        """
        多个关键词逻辑匹配

        :param matchSource: 匹配数据源
        :param matchValue: 需要匹配的关键词
        :return: bool
        """
        matchLogic = "and"
        matchValues = list()
        matches = list()
        if LOGIC_AND_SYMBOL in matchValue:
            matchValues = matchValue.split(LOGIC_AND_SYMBOL)
        if LOGIC_OR_SYMBOL in matchValue:
            matchValues = matchValue.split(LOGIC_OR_SYMBOL)
            matchLogic = "or"
        for value in matchValues:
            value = value.strip()
            if matchLogic == "and":
                if not await self.containsMatch(matchSource, value):
                    return []
                else:
                    matches.append(value)
            if matchLogic == "or":
                if await self.containsMatch(matchSource, value):
                    matches.append(value)
        return matches

    async def matchHeaders(self, headers, matchesObj, matchesItemType):
        """
        HTTP 响应头匹配 会从HTTP响应头的响应名称、响应值、响应名称+响应值中进行完全匹配

        :param headers: Header http响应头头
        :param matchesObj: FpMatches 对象
        :param matchesItemType: 匹配方式
        :return: bool
        """
        if matchesObj.specificHeader:
            return await self.matchSpecificHeader(headers, matchesObj, matchesItemType)
        for key, value in headers.items():
            if await self.matchValues((key + ': ' + value).lower(), matchesObj, matchesItemType):
                return matchesObj.matchesItemValue[matchesItemType]
        return None

    async def matchSpecificHeader(self, headers, matchesObj, matchesItemType):
        """
        特定HTTP响应头匹配

        :param headers: http响应头
        :param matchesObj: FpMatches对象
        :param matchesItemType: 匹配方式
        :return:
        """
        specific = matchesObj.specificHeader.group(1)
        if specific in headers:
            return await self.matchValues(headers[specific], matchesObj, matchesItemType)

    async def asyncMatches(self, asyncRequestObj, responseObj: Response = None, mode="ALL", host=''):
        """
        并发匹配指纹

        :param asyncRequestObj: 已实例化的ExpDepos.libs.core.AsyncRequest对象
        :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
        :param mode: 匹配模式 可选ALL、PASS, AGGR, EXP
        :@param host: 指定特定的host
        :return: list 匹配成功列表
        """
        matches = []
        selfMatches = self.matches
        if mode.upper() == "PASS":
            selfMatches = self.getPassiveMatches()
        if mode.upper() == "AGGR":
            selfMatches = self.getAggressiveMatches()
        if mode.upper() == "EXP":
            selfMatches = self.getExploitMatches()
        for matchesObj in selfMatches:
            if matchesObj.isAggressive:
                match = await self.asyncAggressiveMatches(asyncRequestObj, matchesObj, host=host)
            else:
                if responseObj is None:
                    continue
                match = await self.asyncPassiveMatches(responseObj, matchesObj)
            if self.matchLogic == "and" and not match:
                return {"fp_name": self.name,
                        "percent": 0,
                        "type": self.type,
                        "regByExp": self.regByExp,
                        "matches": matches}
            if match:
                matches.append(match)
        percent = self.percent_of_matches(matches, selfMatches)
        return {"fp_name": self.name,
                "percent": percent,
                "type": self.type,
                "regByExp": self.regByExp,
                "matches": matches}

    def percent_of_matches(self, matches, all_matches):
        """
        计算匹配百分比

        :param matches: 已匹配的匹配项信息
        :type matches: list
        :param all_matches: 所有的匹配项信息
        :type all_matches: list
        :return:
        :rtype:
        """
        if not matches or not all_matches:
            return 0
        matches = self.re_judgment(matches)      # 根据匹配类型重新判定匹配度
        for matched in matches:
            if "certainty" in matched and int(matched["certainty"]) == 100:     # 如果已匹配的匹配项中可能性为100 则返回100
                return 100
        default_percent = 0
        matches_percent = sum(int(match["certainty"]) if "certainty" in match else default_percent for match in matches)
        if matches_percent > 0:
            return int(matches_percent / len(matches))
        # 如果未能重新判定匹配度 则匹配精度按已匹配个数除以总匹配数计算
        default_percent = 100
        all_matches_percent = sum(int(match_obj.certainty) if match_obj.certainty else default_percent
                                  for match_obj in all_matches)
        percent = int((matches_percent / all_matches_percent) * 100)
        return percent

    def re_judgment(self, matches):
        """
        根据匹配类型重新判定匹配度

        :param matches:
        :type matches:
        :return:
        :rtype:
        """
        re_judgment_matches = []
        certainty = 0
        for match in matches:
            if "certainty" not in match:    # 只重判没有定义匹配度的匹配项
                matched = match["matched"]
                method = match["matchMod"]
                if self.is_high_match(match["matchType"]):     # 如果匹配方式为 ["md5", "hash", "regex"] 这类高精度匹配
                    certainty += 90
                if len(matched) > 1:        # 如果匹为多方式 例如同时满足 keyword 及 status
                    certainty += 70
                if method == "aggressive" and certainty > 0:
                    certainty += 20         # 如果是主动匹配方式 再加20的匹配精度
                certainty += self.high_match_position(matched)  # 加上匹配位置评分
                if certainty > 100:     # 最大值为100
                    certainty = 100
                match.update({"certainty": certainty})
            re_judgment_matches.append(match)
        return re_judgment_matches

    def is_high_match(self, match_type):
        for key in match_type:
            if key in ["md5", "hash", "regex"]:
                return True
        return False

    def high_match_position(self, matched):
        certainty = 0
        for match_item in matched:
            if "status" in match_item and not [t for t in ["md5", "hash", "regex"] if t in list(match_item.keys())]:
                continue    # 过滤掉只有 status的主动式匹配项
            position = match_item["position"]
            if "header" in position:
                certainty += 90     # 如果在header中匹配 则匹配度定义为90%
            if re.match(r"header\[(.*)\]", position):
                certainty += 9      # 如果中特定的header中匹配 则匹配度再加9%
            if position == "body":
                certainty += 10
        return certainty

    # def Matches(self, requestObj, responseObj: Response, mode="ALL") -> list:
    #     """
    #     匹配指纹
    #
    #     :param requestObj: 已实例化的ExpDepos.libs.core.Request对象
    #     :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
    #     :param mode: 匹配模式 可选ALL、PASS, AGGR
    #     :return: list 匹配成功列表
    #     """
    #     matches = []
    #     selfMatches = self.matches
    #     if mode.upper() == "PASS":
    #         selfMatches = self.getPassiveMatches()
    #     if mode.upper() == "AGGR":
    #         selfMatches = self.getAggressiveMatches()
    #     for matchesObj in selfMatches:
    #         if matchesObj.isAggressive:
    #             match = self.aggressiveMatches(requestObj, matchesObj)
    #         else:
    #             match = self.passiveMatches(responseObj, matchesObj)
    #         if self.matchLogic == "and" and not match:
    #             return []
    #         if match:
    #             matches.append(match)
    #     return matches

    def Matches(self, moduleObj, responseObj: Response = None, mode="ALL") -> list:
        """
        并发匹配指纹

        :param moduleObj: 已实例化的模块对象
        :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
        :param mode: 匹配模式 可选ALL、PASS, AGGR, EXP
        :return: list 匹配成功列表
        """
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_until_complete(self.asyncMatches(asyncRequestObj=moduleObj.asyncRequest,
                                                                             responseObj=responseObj,
                                                                             mode=mode))

    def getPassiveMatches(self) -> list:
        """
        返回所有被动匹配项列表

        :return: list
        """
        return [match for match in self.matches if not match.isAggressive]

    def getAggressiveMatches(self) -> list:
        """
        返回所有主动匹配项列表

        :return: list
        """
        return [match for match in self.matches if match.isAggressive]

    def getExploitMatches(self) -> list:
        """
        返回当前指纹是从Exploit模块注册的匹配项列表

        :return: list
        """
        return [] if not self.regByExp else self.matches
