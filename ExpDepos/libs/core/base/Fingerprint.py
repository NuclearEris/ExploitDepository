#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/10 10:44
"""

import os
import re
import json
import yaml
import string
import random
import asyncio
import hashlib

from collections import Iterable
from rich.progress import Progress
from ExpDepos.libs.core.Response import Response
from ExpDepos.libs.core.common.Common import env, console
from ExpDepos.libs.core.common.Console import formatPgString
from ExpDepos.libs.core.common.Enums import FINGERPRINT, ENUMS
from ExpDepos.libs.core.base.ExceptionBase import ExpDeposFingerprintException

ALLOW_SETS = FINGERPRINT.ALLOW_SETS
ALLOW_LOGICS = FINGERPRINT.ALLOW_LOGICS
ALLOW_MATCHES_ITEM = FINGERPRINT.ALLOW_MATCHES_ITEM
ALLOW_MATCHES_SEARCH_ITEM = FINGERPRINT.ALLOW_MATCHES_SEARCH_ITEM
ALLOW_MATCHES_VALUE_TYPE = FINGERPRINT.ALLOW_MATCHES_VALUE_TYPE
ALLOW_MATCHES_VALUE_ATTR = FINGERPRINT.ALLOW_MATCHES_VALUE_ATTR
ALLOW_FILTERS_ITEM = {"platform": ENUMS.PLATFORM,
                      "middleware": ENUMS.MIDDLEWARE,
                      "language": ENUMS.SCRIPT_LANGUAGE}
LOGIC_AND_SYMBOL = '<&&>'
LOGIC_OR_SYMBOL = '<||>'


def dump(fp):
    """
    将指纹信息转换成YAML格式

    :param fp: 指纹信息
    :return: str
    """
    return yaml.dump(fp)


def register(fp: dict):
    """
    注册指纹信息

    :param fp: 指纹信息
    :return:
    """
    fileName = formatFileName(fp["name"]) if 'fileName' not in fp else fp.pop('fileName')
    filePath = env.Config.FINGER_PATH + os.sep + fileName + ".yaml"
    loadFp = loadFromFile(fileName)
    fpDump = dump(fp)
    if not loadFp or loadFp != yaml.load(fpDump, Loader=yaml.SafeLoader):
        with open(filePath, "w", encoding="UTF-8") as fpFile:
            return fpFile.write(fpDump)
    return False


def getFpFilePath(fileName: str):
    """
    获取指纹信息文件绝对路径

    :param fileName: 指纹文件名
    :return:
    """
    return env.Config.FINGER_PATH + os.sep + fileName + (".yaml" if not fileName.endswith(".yaml") else '')


def loadFromFile(fileName: str):
    """
    从YAML文件中加载指纹信息

    :param fileName: 指纹名称或文件名
    :return:
    """
    fileName = formatFileName(fileName)
    filePath = getFpFilePath(fileName)
    try:
        return yaml.load(open(filePath, "rb"), Loader=yaml.SafeLoader)
    except FileNotFoundError:
        return None


def setCache(configList):
    """
    写入缓存

    :param configList: 指纹配置信息列表
    :return:
    """
    cacheDir = env.Config.DATA_PATH + os.sep + 'fingerprint'
    if not os.path.exists(cacheDir):
        os.makedirs(cacheDir)
    filePath = cacheDir + os.sep + 'fpConfigs.json'
    with open(filePath, "w", encoding="UTF-8") as cacheFile:
        return cacheFile.write(json.dumps(configList))


def getCache():
    """
    从缓存文件中获取指纹信息列表

    :return: list
    """
    cacheDir = env.Config.DATA_PATH + os.sep + 'fingerprint'
    filePath = cacheDir + os.sep + 'fpConfigs.json'
    if os.path.exists(filePath):
        with open(filePath, "r", encoding="UTF-8") as cacheFile:
            return json.loads(cacheFile.read())
    return None


def getCacheOfFile(filename, caches):
    """
    根据文件名从缓存列表中获取指纹信息

    :param filename: 文件名
    :param caches: 缓存列表
    :return:
    """
    if caches:
        for cache in caches:
            if filename in cache and cache[filename]:
                return cache
    return None


def fileHash(file):
    """
    计算文件hash值

    :param file: 文件名
    :return:
    """
    filePath = getFpFilePath(file)
    with open(filePath, "rb") as file:
        return hashlib.md5(file.read()).hexdigest()


def loadFingerprints() -> list:
    """
    加载所有指纹信息

    :return: list
    """
    fpList = []
    filePath = env.Config.FINGER_PATH
    fileList = os.listdir(filePath)
    configList = []
    cacheFp = getCache()
    if not cacheFp:
        console.debug("[red]can't load cacheFp from cache file.[/red]")
    with Progress() as progress:
        task = progress.add_task(formatPgString("[green]正在初始化指纹库...[/green]"), total=len(fileList))
        for file in fileList:
            file_hash = fileHash(file)
            fileCache = getCacheOfFile(file, cacheFp)
            if fileCache and file_hash == fileCache[file]["hash"]:
                fpConfig = fileCache[file]["config"]
            else:
                fpConfig = loadFromFile(file)
            if fpConfig:
                configList.append({file: {"hash": fileHash(file), "config": fpConfig}})
                fpList.append(instanceFingerprint(fpConfig))
            progress.update(task, advance=1)
    setCache(configList)
    return fpList


def formatFileName(fpName):
    """
    格式化文件名

    :param fpName: 指纹名称
    :return: str
    """
    return fpName.replace(" ", "_").replace(":", "_")


def availableSets(sets: dict) -> dict:
    """
    校验参数设置合法性

    :param sets: 参数设置信息
    :return: dict
    """
    for setItem in sets.keys():
        if setItem.lower() not in ALLOW_SETS:
            raise ExpDeposFingerprintException("未被允许的参数设置项：[yellow]{0}[yellow]"
                                               " 只允许[green]{1}[/green]".format(setItem, ALLOW_SETS))
    return sets


def availableMatchLogic(logic):
    """
    校验匹配逻辑

    :param logic: 逻辑字符串
    :return: str
    """
    if logic.lower() not in ALLOW_LOGICS:
        raise ExpDeposFingerprintException("错误的匹配逻辑 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                           .format(logic, ALLOW_LOGICS))
    return logic


def availableSearchItems(searchItem: str):
    """
    校验匹配范围的合法性

    :param searchItem:
    :return: str
    """
    if searchItem.lower() not in ALLOW_MATCHES_SEARCH_ITEM \
            and not availableSpecificHeader(searchItem):
        raise ExpDeposFingerprintException("错误的匹配项 [yellow]{0}[/yellow]."
                                           " 只允许: [green]{1}[/green]".format(searchItem, ALLOW_MATCHES_SEARCH_ITEM))
    return searchItem


def availableSpecificHeader(searchItem: str):
    return re.match(r"headers\[([\w-]+)\]", searchItem)


def availableFilters(filters: dict):
    """
    校验过滤器合法性

    :param filters: 过滤器信息
    :return: dict
    """
    for filterItem in filters.keys():
        if filterItem.lower() not in ALLOW_FILTERS_ITEM.keys():
            raise ExpDeposFingerprintException("错误的过滤项 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                               .format(filterItem, ALLOW_FILTERS_ITEM.keys()))
        if not isinstance(filters[filterItem], list):
            filters[filterItem] = [filters[filterItem]]
        for filterValue in filters[filterItem]:
            if filterValue.lower() not in ALLOW_FILTERS_ITEM[filterItem]:
                raise ExpDeposFingerprintException("错误的过滤值 [yellow]{0}[/yellow], 只允许 [green]{1}[/green]"
                                                   .format(filterValue, ALLOW_FILTERS_ITEM[filterItem]))
    return filters


def instanceMatches(matches: list) -> list:
    """
    实例指纹匹配对象

    :param matches: 指纹匹配项列表
    :return: list
    """
    return [FpMatches(matchesItem) for matchesItem in matches]


def instanceFingerprint(fp: dict):
    if "name" not in fp and not fp["name"]:
        raise ExpDeposFingerprintException("未命名的指纹配置信息.")
    author = fp['author'] if 'author' in fp and fp['author'] else 'Anonymous'
    version = fp['version'] if 'version' in fp and fp['version'] else None
    fpType = fp["type"] if 'type' in fp and fp["type"] else FINGERPRINT.FP_TYPE.WEBAPP
    sets = fp['sets'] if 'sets' in fp and fp['sets'] else None
    description = fp["description"] if 'description' in fp and fp["description"] else None
    website = fp["website"] if 'website' in fp and fp["website"] else None
    filters = fp["filters"] if 'filters' in fp and fp["filters"] else None
    logic = fp["logic"] if 'logic' in fp and fp["logic"] else 'or'
    regByExp = fp["regByExp"] if 'regByExp' in fp and fp["regByExp"] else False
    return Fingerprint(name=fp["name"],
                       author=author,
                       version=version,
                       fpType=fpType,
                       sets=sets,
                       description=description,
                       website=website,
                       filters=filters,
                       matches=fp["matches"],
                       matchLogic=logic,
                       regByExp=regByExp)


def randstr(length: int = 5, number: bool = False) -> str:
    """
    随机字符生成器

    :param length: 生成长度
    :param number: 是否全数字
    :return: str
    """
    if number:
        return "".join(random.sample(string.digits, length))
    return "".join(random.sample(string.ascii_letters + string.digits, length))


def isRandom(strObj: str) -> any:
    """
    验证是否使用随机数生成器

    :param strObj: 含有 {randstr()}标识的字符串
    :return: bool
    """
    return re.search(r"(\{randstr\((?:length=)?((?:\d){1,2})?,?\s?(?:number=)?(True|true|False|false)?\)\})", strObj)


def getRandArgs(strObj: str):
    """
    获取randstr函数的参数值

    :param strObj: 含有 {randstr()}标识的字符串
    :return:
    """
    match = re.search(r"\{randstr\((?:length=)?((?:\d){1,2})?,\s??(?:number=)?(True|true|False|false)?\)\}", strObj)
    try:
        length = int(match.group(1))
    except AttributeError:
        length = 5
    except TypeError:
        length = 5
    try:
        number = True if match.group(2).lower() == 'true' else False
    except AttributeError:
        number = False
    return length, number


def makeRandstr(objs):
    """
    生成随字符串

    :param objs: 含有 {randstr()}标识的字典、列表、字符串对象
    :return:
    """
    if isinstance(objs, Iterable):
        if isinstance(objs, dict):
            for key, value in objs.items():
                key = makeRandstr(key)
                value = makeRandstr(value)
                objs.update({key: value})
            return objs
        if isinstance(objs, list):
            for value in objs:
                objs[objs.index(value)] = makeRandstr(value)
            return objs
    israndom = isRandom(objs)
    if israndom:
        length, number = getRandArgs(objs)
        objs = objs.replace(israndom.group(1), randstr(length, number))
    return objs


class FpMatches(object):
    """
    指纹匹配项
    """

    def __init__(self, matchesItem: dict):
        matchesItemKeys = list(matchesItem.keys())
        self._matchesItem = "text"  # 默认匹配项目为response.text
        self._requestUrl = None
        self._certainty = None
        self._isAggressive = False
        self._aim = None
        self._name = None
        self._offset = None
        if 'name' in matchesItem:
            self._name = matchesItem['name']
        if 'url' in matchesItem:
            self._isAggressive = True  # 包含了url项则该指纹匹配项为主动式匹配
            self._requestUrl = matchesItem["url"]
            if 'status' not in matchesItem:
                matchesItem.update({"status": 200})  # 主动匹配默认要求URL状态为200
        if 'search' in matchesItem:
            self._matchesItem = availableSearchItems(matchesItem["search"])
        if 'certainty' in matchesItem:
            self._certainty = matchesItem['certainty']
        if 'offset' in matchesItem:
            self._offset = matchesItem['offset']
        if 'aim' in matchesItem:
            self._aim = matchesItem['aim']
        if 'status' in matchesItem:
            self._matchesItem = 'http'
        self._specificHeader = availableSpecificHeader(self._matchesItem)
        self._matchesItemType = self.getMatchesItemType(matchesItemKeys)
        self._matchesItemValue = matchesItem

    @property
    def name(self):
        return self._name

    @property
    def isAggressive(self):
        return self._isAggressive

    @property
    def matchesItem(self):
        return self._matchesItem

    @property
    def matchesItemType(self):
        return self._matchesItemType

    @property
    def matchesItemValue(self):
        return self._matchesItemValue

    @property
    def specificHeader(self):
        return self._specificHeader

    @property
    def requestUrl(self):
        return self._requestUrl

    @property
    def certainty(self):
        return self._certainty

    @property
    def offset(self):
        return self._offset

    @property
    def aim(self):
        return self._aim

    @staticmethod
    def getMatchesItemType(matchesItemKeys):
        """
        获取匹配方式

        :param matchesItemKeys: 指纹配置字典的键值列表
        :return:
        """
        ckList = [itemKey for itemKey in matchesItemKeys if itemKey in ALLOW_MATCHES_VALUE_TYPE]
        if not ckList:
            raise ExpDeposFingerprintException("指纹配置错误!未找到任何可识别的匹配方式.")
        return ckList


class Fingerprint(object):
    """
    指纹识别
    """

    def __init__(self, name: str,
                 version: str,
                 author: list,
                 matches: list,
                 matchLogic: str = "or",
                 description: str = "",
                 website: str = "",
                 fpType: str = FINGERPRINT.FP_TYPE.WEBAPP,
                 sets: dict = None,
                 filters: dict = None,
                 regByExp: bool = False):
        self._Name = name
        self._Version = version
        self._Author = author
        self._Matches = instanceMatches(matches)
        self._MatchLogic = availableMatchLogic(matchLogic)
        self._description = description
        self._website = website
        self._Sets = availableSets(sets) if sets is not None else sets
        self._Filters = availableFilters(filters) if filters is not None else filters
        self._type = fpType
        self._regByExp = regByExp
        pass

    @property
    def name(self):
        return self._Name

    @property
    def version(self):
        return self._Version

    @property
    def author(self):
        return self._Author

    @property
    def matches(self):
        return self._Matches

    @property
    def matchLogic(self):
        return self._MatchLogic

    @property
    def description(self):
        return self._description

    @property
    def website(self):
        return self._website

    @property
    def sets(self):
        return self._Sets

    @property
    def filters(self):
        return self._Filters

    @property
    def type(self):
        return self._type

    @property
    def regByExp(self):
        return self._regByExp

    def getSets(self):
        """
        获取HTTP 请求设置

        :return:
        """
        if self.sets:
            headers = cookies = data = params = None
            if 'headers' in self.sets and self.sets['headers']:
                headers = self.sets['headers']
                if not isinstance(headers, dict):
                    raise ExpDeposFingerprintException("设置的[green]Headers[/green]参数应为键值对应的字典格式.")
            if 'cookies' in self.sets and self.sets["cookies"]:
                cookies = self.sets["cookies"]
                if not isinstance(cookies, dict):
                    raise ExpDeposFingerprintException("设置的[green]Cookies[/green]参数应为键值对应的字典格式.")
            if 'data' in self.sets:
                data = self.sets["data"]
            if 'params' in self.sets and self.sets["params"]:
                params = self.sets["params"]
                if not isinstance(params, dict):
                    raise ExpDeposFingerprintException("设置的[green]GET[/green]参数应为键值对应的字典格式.")
            return makeRandstr(headers), makeRandstr(cookies), makeRandstr(data), makeRandstr(params)
        return None, None, None, None

    def aggressiveMatches(self, request, matchesObj: FpMatches):
        """
        主动式匹配

        :param request: request对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        method = "GET"
        headers, cookies, data, params = self.getSets()
        if data or data == '':
            method = "POST"
        response = request.request(method=method,
                                   url=makeRandstr(matchesObj.requestUrl),
                                   headers=headers,
                                   cookies=cookies,
                                   data=data,
                                   params=params,
                                   allow_redirects=False)
        return self.passiveMatches(response=response, matchesObj=matchesObj)

    async def asyncAggressiveMatches(self, asyncRequest, matchesObj: FpMatches):
        """
        并发主动式匹配

        :param asyncRequest: AsyncRequest对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        method = "GET"
        headers, cookies, data, params = self.getSets()
        if data or data == '':
            method = "POST"
        response = await asyncRequest.request(method=method,
                                              url=makeRandstr(matchesObj.requestUrl),
                                              headers=headers,
                                              cookies=cookies,
                                              data=data,
                                              params=params,
                                              allow_redirects=False)
        if response.status_code != matchesObj.matchesItemValue['status']:
            return None     # 主动匹配如果response.status_code不匹配则后续不用再继续匹配
        return await self.passiveMatches(response=response, matchesObj=matchesObj)

    async def passiveMatches(self, response: Response, matchesObj: FpMatches):
        """
        被动匹配

        :param response: http response对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        matched = []
        # 每一个匹配规则都有一个或者多个匹配方式
        # 这些匹配方式需要全部满足该匹配规则才算匹配成功
        for matchesItemType in matchesObj.matchesItemType:
            match = await self.match(response=response, matchesObj=matchesObj, matchesItemType=matchesItemType)
            if not match:
                return None
            matched.extend([{matchesItemType: match}])
        if matched:
            matchResult = {"name": self.name + '.' + matchesObj.name if matchesObj.name else self.name,
                           "matchMod": "aggressive" if matchesObj.isAggressive else "passive",
                           "matchType": matchesObj.matchesItemType}
            if self.regByExp:
                matchResult.update({"regByExp": self.regByExp})
            if matchesObj.certainty:
                matchResult.update({"certainty": matchesObj.certainty})
            if matchesObj.requestUrl:
                matchResult.update({"matchUrl": matchesObj.requestUrl})
            if matchesObj.aim:
                aimValue = matchesObj.matchesItemValue[matchesObj.aim] \
                    if matchesObj.aim in matchesObj.matchesItemValue else matched
                matchResult.update({matchesObj.aim: aimValue})
            matchResult.update({"matched": matched})
            return matchResult
        return None

    async def asyncPassiveMatches(self, response: Response, matchesObj: FpMatches):
        """
        并发被动匹配

        :param response: http response对象
        :param matchesObj: 需要匹配的FpMatches对象
        :return:
        """
        return await self.passiveMatches(response=response, matchesObj=matchesObj)

    async def match(self, response, matchesObj, matchesItemType):
        """
        匹配规则

        :param response: Response对象
        :param matchesObj: FpMatches 对象
        :param matchesItemType: 匹配方式
        :return:
        """
        if matchesItemType == "status":
            if response.status_code == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesItemType == "hash":
            if response.hash == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesItemType == "md5":
            if response.md5sum == matchesObj.matchesItemValue[matchesItemType]:
                return matchesObj.matchesItemValue[matchesItemType]
        if matchesObj.matchesItem == "headers" or matchesObj.specificHeader:
            return await self.matchHeaders(response.headers, matchesObj, matchesItemType)
        return await self.matchValues(matchSource=response.text, matchesObj=matchesObj, matchesItemType=matchesItemType)

    async def matchValues(self, matchSource, matchesObj, matchesItemType):
        """
        内容匹配

        :param matchSource: 匹配数据源
        :param matchesObj: FpMatches对象
        :param matchesItemType: 匹配方式
        :return:
        """
        if matchesItemType == "keyword":
            return await self.matchKeywords(matchSource, matchesObj.matchesItemValue[matchesItemType])
        if matchesItemType == "regex":
            matches = await self.regexMatch(matchSource, matchesObj.matchesItemValue[matchesItemType])
            if matches:
                return matches.group(matchesObj.offset) if matchesObj.offset else matches

    @staticmethod
    async def containsMatch(source: str, keyword: str):
        """
        关键词包含匹配

        :param source: 匹配数据源
        :param keyword: 关键词
        :return:
        """
        if keyword.lower() in source.lower():
            return keyword
        return None

    @staticmethod
    async def splitLonStr(source: str) -> list:
        """
        分割过长的行为多行，防止正则回溯耗时太长

        :param source:
        :return:
        """
        splitStr = source.split("\n")
        rebuild = list()
        for line in splitStr:
            if len(line) > 1000:
                rebuild.extend([line[i:i + 1000] for i in range(0, len(line), 1000)])
                continue
            rebuild.append(line)
        return rebuild

    @staticmethod
    async def regexMatch(source, regex):
        """
        正则匹配

        :param source: 匹配数据源
        :param regex: 正则表达式
        :return:
        """
        source_list = await Fingerprint.splitLonStr(source)
        for source in source_list:
            match = re.search(regex, source)
            if match:
                return match
        return None

    async def matchKeywords(self, matchSource, matchValue):
        """
        关键词匹配

        :param matchSource: 匹配数据源
        :param matchValue: 需要匹配的关键词
        :return:
        """
        if isinstance(matchValue, str) and (LOGIC_AND_SYMBOL in matchValue or LOGIC_OR_SYMBOL in matchValue):
            # 多关键词逻辑匹配
            return await self.multiKeywordsMatch(matchSource=matchSource, matchValue=matchValue)
        if not isinstance(matchValue, str):
            matchValue = str(matchValue)
            return await self.containsMatch(matchSource, matchValue)

    async def multiKeywordsMatch(self, matchSource, matchValue: str):
        """
        多个关键词逻辑匹配

        :param matchSource: 匹配数据源
        :param matchValue: 需要匹配的关键词
        :return: bool
        """
        matchLogic = "and"
        matchValues = list()
        matches = list()
        if LOGIC_AND_SYMBOL in matchValue:
            matchValues = matchValue.split(LOGIC_AND_SYMBOL)
        if LOGIC_OR_SYMBOL in matchValue:
            matchValues = matchValue.split(LOGIC_OR_SYMBOL)
            matchLogic = "or"
        for value in matchValues:
            value = value.strip()
            if matchLogic == "and":
                if not await self.containsMatch(matchSource, value):
                    return []
                else:
                    matches.append(value)
            if matchLogic == "or":
                if await self.containsMatch(matchSource, value):
                    matches.append(value)
        return matches

    async def matchHeaders(self, headers, matchesObj, matchesItemType):
        """
        HTTP 响应头匹配 会从HTTP响应头的响应名称、响应值、响应名称+响应值中进行完全匹配

        :param headers: Header http响应头头
        :param matchesObj: FpMatches 对象
        :param matchesItemType: 匹配方式
        :return: bool
        """
        if matchesObj.specificHeader:
            return await self.matchSpecificHeader(headers, matchesObj, matchesItemType)
        for key, value in headers.items():
            if await self.matchValues((key + ': ' + value).lower(), matchesObj, matchesItemType):
                return matchesObj.matchesItemValue[matchesItemType]
        return None

    async def matchSpecificHeader(self, headers, matchesObj, matchesItemType):
        """
        特定HTTP响应头匹配

        :param headers: http响应头
        :param matchesObj: FpMatches对象
        :param matchesItemType: 匹配方式
        :return:
        """
        specific = matchesObj.specificHeader.group(1)
        if specific in headers:
            return await self.matchValues(headers[specific], matchesObj, matchesItemType)

    async def asyncMatches(self, asyncRequestObj, responseObj: Response, mode="ALL"):
        """
        并发匹配指纹

        :param asyncRequestObj: 已实例化的ExpDepos.libs.core.AsyncRequest对象
        :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
        :param mode: 匹配模式 可选ALL、PASS, AGGR, EXP
        :return: list 匹配成功列表
        """
        matches = []
        selfMatches = self.matches
        if mode.upper() == "PASS":
            selfMatches = self.getPassiveMatches()
        if mode.upper() == "AGGR":
            selfMatches = self.getAggressiveMatches()
        if mode.upper() == "EXP":
            selfMatches = self.getExploitMatches()
        for matchesObj in selfMatches:
            if matchesObj.isAggressive:
                match = await self.asyncAggressiveMatches(asyncRequestObj, matchesObj)
            else:
                match = await self.asyncPassiveMatches(responseObj, matchesObj)
            if match:
                matches.append(match)
        return matches

    # def Matches(self, requestObj, responseObj: Response, mode="ALL") -> list:
    #     """
    #     匹配指纹
    #
    #     :param requestObj: 已实例化的ExpDepos.libs.core.Request对象
    #     :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
    #     :param mode: 匹配模式 可选ALL、PASS, AGGR
    #     :return: list 匹配成功列表
    #     """
    #     matches = []
    #     selfMatches = self.matches
    #     if mode.upper() == "PASS":
    #         selfMatches = self.getPassiveMatches()
    #     if mode.upper() == "AGGR":
    #         selfMatches = self.getAggressiveMatches()
    #     for matchesObj in selfMatches:
    #         if matchesObj.isAggressive:
    #             match = self.aggressiveMatches(requestObj, matchesObj)
    #         else:
    #             match = self.passiveMatches(responseObj, matchesObj)
    #         if self.matchLogic == "and" and not match:
    #             return []
    #         if match:
    #             matches.append(match)
    #     return matches

    def Matches(self, moduleObj, responseObj: Response, mode="ALL") -> list:
        """
        并发匹配指纹

        :param moduleObj: 已实例化的模块对象
        :param responseObj: 已实例化的ExpDepos.libs.core.Response对象
        :param mode: 匹配模式 可选ALL、PASS, AGGR, EXP
        :return: list 匹配成功列表
        """
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_until_complete(self.asyncMatches(asyncRequestObj=moduleObj.asyncRequest,
                                                                             responseObj=responseObj,
                                                                             mode=mode))

    def getPassiveMatches(self) -> list:
        """
        返回所有被动匹配项列表

        :return: list
        """
        return [match for match in self.matches if not match.isAggressive]

    def getAggressiveMatches(self) -> list:
        """
        返回所有主动匹配项列表

        :return: list
        """
        return [match for match in self.matches if match.isAggressive]

    def getExploitMatches(self) -> list:
        """
        返回当前指纹是从Exploit模块注册的匹配项列表

        :return: list
        """
        return [] if not self.regByExp else self.matches
