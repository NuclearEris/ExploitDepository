#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/7/6 15:16
"""

import re
import os
import ast
import sys
import importlib
from _ast import Import, ImportFrom, FunctionDef, Assign
from ExpDepos.libs.core.common.Common import get_encoding
from typing import Any


class ModuleAnalyzer(ast.NodeTransformer):
    """
    Python库中的modulefinder在windows上存在兼容性问题
    自己实现通过源码分析方式查找模块依赖
    """

    def __init__(self, filePath):
        """
        :param filePath: 源文件路径
        """
        self.filePath = filePath

        self.modules = list()
        self.unload_modules = list()
        self.isExpModule = False
        self.isPayload = False
        self.isEncoder = False
        self.assigns = {"Type": ''}

        # 添加源文件路径到sys.path中 以便引入源文件所在路径下的模块
        sys.path.append(os.path.abspath(os.path.dirname(filePath)))

    def add_module(self, module):
        """
        添加并验证模块名称
        :param module: 模块名称
        :return:
        """
        self.modules.append(module)
        try:
            importlib.import_module(module)
        except ModuleNotFoundError as e:
            """
            修复模块依赖检查中无法正确定位导入失败的模块名(依赖嵌套中无法import的模块始终显示的是顶层的模块名)
            """
            match = re.match(r"No module named '(\w*)'", e.args[0])
            if match:
                self.unload_modules.append(match.group(1))

    def visit_Import(self, node: Import) -> Any:
        """
        重写父类visit_Import方法解析Import语法
        :param node:
        :return:
        """
        for i in node.names:
            self.add_module(i.name)

    def visit_ImportFrom(self, node: ImportFrom) -> Any:
        """
        重写父类visit_ImportFrom方法解析from x import语法
        :param node:
        :return:
        """
        self.add_module(node.module)

    def visit_FunctionDef(self, node: FunctionDef) -> Any:
        """
        重写父类visit_FunctionDef方法解析函数定义 确认是否为Exploit 模块

        :param node:
        :return:
        """
        if node.name == "_exploit" or node.name == "_verify":
            self.isExpModule = True
            self.assigns.update({"Type": "exploit"})
        if node.name == "_generate":
            self.isPayload = True
            self.assigns.update({"Type": "payload"})
        if node.name == "_encode":
            self.isEncoder = True
            self.assigns.update({"Type": "encoder"})

    def visit_Assign(self, node: Assign) -> Any:
        """
        重写父类 visit_Assign 方法解析模块属性定义

        :param node:
        :return:
        """
        if isinstance(node.targets[0], ast.Name):
            name = node.targets[0].id
            value = self.get_node_value(node.value)
            self.assigns.update({name: value})

    def get_node_value(self, node):
        if isinstance(node, ast.Constant):
            return node.value
        if isinstance(node, ast.Str):  # 低版本value类型为ast.Str
            return node.s
        if isinstance(node, ast.List):
            return [self.get_node_value(valueObj) for valueObj in node.elts]
        if isinstance(node, ast.Num):
            return node.n
        if isinstance(node, ast.Tuple):
            return tuple([self.get_node_value(valueObj) for valueObj in node.elts])
        return None

    def analysis(self):
        """
        解析文件源码返回节点类，交由visit方法
        :return:
        """
        with open(self.filePath, "rt", encoding=get_encoding(self.filePath)) as fp:
            self.visit(ast.parse(fp.read(), self.filePath))
