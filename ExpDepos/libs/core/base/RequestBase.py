#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/8/28 22:39
"""
import random
import typing
from rich.progress import Progress
from httpx import BaseTransport, Headers
from ExpDepos.libs.core.common.Common import console
from httpx._client import ACCEPT_ENCODING
from httpx._config import DEFAULT_TIMEOUT_CONFIG, Limits, DEFAULT_LIMITS, DEFAULT_MAX_REDIRECTS
from httpx._types import URLTypes, QueryParamTypes, HeaderTypes, CookieTypes, AuthTypes, TimeoutTypes, VerifyTypes, \
    CertTypes, ProxiesTypes


class RequestBase(object):
    def __init__(self,
                 *,
                 auth: AuthTypes = None,
                 params: QueryParamTypes = None,
                 headers: HeaderTypes = None,
                 cookies: CookieTypes = None,
                 verify: VerifyTypes = True,
                 cert: CertTypes = None,
                 http1: bool = True,
                 http2: bool = False,
                 proxies: ProxiesTypes = None,
                 mounts: typing.Mapping[str, BaseTransport] = None,
                 timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,
                 limits: Limits = DEFAULT_LIMITS,
                 max_redirects: int = DEFAULT_MAX_REDIRECTS,
                 event_hooks: typing.Mapping[str, typing.List[typing.Callable]] = None,
                 base_url: URLTypes = "",
                 transport: BaseTransport = None,
                 app: typing.Callable = None,
                 trust_env: bool = True,
                 retries: int = 0,
                 rdelay: int = 0,
                 delay: int = 0,
                 use_scf: bool = False,
                 scf_cfg: dict = None, ):
        """
        扩展和封装httpx.Client对象

        :param auth: (optional)An authentication class to use when sending requests.
        :param params: (optional)Query parameters to include in request URLs,
                        as a string, dictionary, or sequence of two-tuples.
        :param headers: (optional)Dictionary of HTTP headers to include when sending requests.
        :param cookies: (optional)Dictionary of Cookie items to include when sending requests.
        :param verify: (optional)SSL certificates (a.k.a CA bundle) used to verify the identity of requested hosts.
                        Either True (default CA bundle), a path to an SSL certificate file,
                        an ssl.SSLContext, or False (which will disable verification).
        :param cert: (optional)An SSL certificate used by the requested host to authenticate the client.
                        Either a path to an SSL certificate file, or two-tuple of (certificate file, key file),
                         or a three-tuple of (certificate file, key file, password).
        :param http1: (optional)A boolean indicating if HTTP/1 support should be enabled. Defaults to True.
        :param http2: (optional)A boolean indicating if HTTP/2 support should be enabled. Defaults to False.
        :param proxies: (optional)A dictionary mapping HTTP protocols to proxy URLs.
        :param timeout: (optional) The timeout configuration to use when sending requests.
        :param limits: (optional) The limits configuration to use.
        :param max_redirects: (optional) The maximum number of redirect responses that should be
        :param base_url: (optional) A URL to use as the base when building request URLs.
        :param transport: (optional) A transport class to use for sending requests over the network.
        :param app: (optional) An ASGI application to send requests to, rather than sending actual network requests.
        :param trust_env: (optional) Enables or disables usage of environment variables for configuration.
        :param retries: 请求失败后重试次数
        :param delay: 两次请求之间的间隔时间
        :param rdelay: 请求失败后重试间隔时间
        :param use_scf: 是否使用云函数代理
        :param scf_cfg: 云函数配置信息
        """
        self._retries = retries
        self._rdelay = rdelay
        self._delay = delay
        self._useScf = use_scf
        self._scfCfg = scf_cfg
        self._scfTest = False
        self._scfTestUrl = []
        self._progress = None  # 当request请求位于rich.Progress中时用于消息输出当Progress对象
        super().__init__(
            auth=auth,
            params=params,
            headers=headers,
            cookies=cookies,
            verify=verify,
            cert=cert,
            http1=http1,
            http2=http2,
            proxies=proxies,
            mounts=mounts,
            timeout=timeout,
            limits=limits,
            max_redirects=max_redirects,
            event_hooks=event_hooks,
            base_url=base_url,
            transport=transport,
            app=app,
            trust_env=trust_env,
        )

    @property
    def retries(self) -> int:
        return self._retries

    @retries.setter
    def retries(self, retrie: int):
        self._retries = retrie

    @property
    def in_progress(self):
        return False if self._progress is None else True

    def set_progress(self, progress: Progress):
        self._progress = progress

    def get_progress(self):
        return self._progress

    @property
    def rdelay(self) -> int:
        return self._rdelay

    @property
    def delay(self) -> int:
        return self._delay

    @property
    def useScf(self) -> bool:
        return self._useScf

    @useScf.setter
    def useScf(self, use_scf: bool):
        self._useScf = use_scf

    @property
    def scfTest(self):
        return self._scfTest

    @scfTest.setter
    def scfTest(self, is_test: bool):
        self._scfTest = is_test

    @property
    def scfTestUrl(self):
        return self._scfTestUrl

    @scfTestUrl.setter
    def scfTestUrl(self, url):
        self._scfTestUrl.append({"user": "test",
                                 "cloudType": "tencent",
                                 "region": "chengdu",
                                 "api": url,
                                 "accessKeys": "test"
                                 })

    @property
    def scfCfg(self) -> dict:
        return self._scfCfg

    @scfCfg.setter
    def scfCfg(self, cfg: dict):
        self._scfCfg.update(cfg)

    @property
    def headers(self) -> Headers:
        """
        HTTP headers to include when sending requests.
        """
        return self._headers

    @headers.setter
    def headers(self, headers: HeaderTypes) -> None:
        client_headers = self.headers if getattr(self, "_headers", None) else Headers(
            {
                b"Accept": b"*/*",
                b"Accept-Encoding": ACCEPT_ENCODING.encode("ascii"),
                b"Connection": b"keep-alive",
                b"User-Agent": "",
            }
        )
        client_headers.update(headers)
        self._headers = client_headers

    def scfApiRandom(self):
        """
        随机返回云函数API接口地址

        :return:
        """
        if self.scfTest:
            return random.choice(self.scfTestUrl)
        scfApis = []
        if self.scfCfg:
            for user, userScf in self.scfCfg.items():
                for cloudType, scfConfigs in userScf.items():
                    for scfConfig in scfConfigs:
                        for region, scfInfo in scfConfig.items():
                            scfApis.append({"user": user,
                                            "cloudType": cloudType,
                                            "region": region,
                                            "api": scfInfo[0]["subDomain"][0],
                                            "accessKeys": scfInfo[0]["accessKeys"]
                                            })
        return random.choice(scfApis)

    def pprint(self, message):
        if self.in_progress:
            progress = self.get_progress()
            progress.print(message)
        else:
            console.print(message)
