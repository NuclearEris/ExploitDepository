#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2022/4/1 10:48
"""

import re
from rich import box
from rich.live import Live
from rich.panel import Panel
from rich.table import Table
from rich.progress import Progress, BarColumn, TextColumn, SpinnerColumn
from ExpDepos.libs.core.common.Common import console, timeit
from ExpDepos.libs.core.common.Console import formatString
from ExpDepos.libs.core.base.Fingerprint import availableFilters


def parse_aim_value(aim_values: list, aim_value):
    """
    递归解析aim值

    :param aim_values: 用于存储解析值的字典
    :type aim_values: dict
    :param aim_value: 需要解析的值
    :type aim_value: any
    :return:
    :rtype:
    """
    if isinstance(aim_value, str):
        aim_values.append(aim_value)
    if isinstance(aim_value, list):
        for aim_v in aim_value:
            parse_aim_value(aim_values, aim_v)
    if isinstance(aim_value, re.Match):
        parse_aim_value(aim_values, aim_value.groups())
    if isinstance(aim_value, dict):
        keys = aim_value.keys()
        for key in keys:
            if key in ["regex", "keyword"]:
                parse_aim_value(aim_values, aim_value.get(key))
    if isinstance(aim_value, tuple):
        aim_values.append(" ".join(aim_value))
    return


def get_aim_info(fp):
    """
    获取指纹匹配aim信息

    :param fp: 指纹匹配信息
    :type fp: dict
    :return:
    :rtype:
    """
    aim_info = {}
    for match in fp["matches"]:
        if "aim" in match:
            aim_values = []
            aim = match["aim"]
            if aim in match:
                parse_aim_value(aim_values, match[aim])
            if aim in aim_info:     # 如果aim_info是否已存在该键值，则扩展并去重
                aim_values.extend(aim_info.get(aim))
                aim_info.update({aim: list(set(aim_values))})       # 去重
            else:
                aim_info.update({aim: aim_values})
    return aim_info


def show_result(result):
    """
    可视化展示匹配结果

    :param result: 指纹匹配结果集
    :type result: list
    :return:
    :rtype:
    """
    result_grid = Table.grid()
    result_table = Table.grid()
    result_progress = Progress("{task.description}",
                               SpinnerColumn(),
                               BarColumn(bar_width=50),
                               TextColumn("[progress.percentage]{task.percentage:>3.0f}% Possibility"))
    for fp in result:
        exp = ''
        aim = ''
        ext_info = ''
        if fp["regByExp"]:
            exp_name = fp["regByExp"]
            exp_name = exp_name[exp_name.rindex(".") + 1:]
            exp = f"[bold yellow]exp: [/bold yellow][bold red]{exp_name}[/bold red]"
        aim_info = get_aim_info(fp)
        if aim_info:
            for k, v in aim_info.items():
                aim += f"[bold yellow]{k}:[/bold yellow]" \
                       f" [bold magenta]{' '.join(v) if isinstance(v, list) else v}[/bold magenta]"
        if exp or aim:
            info_list = []
            if exp:
                info_list.append(exp)
            if aim:
                info_list.append(aim)
            ext_info = f"({', '.join(info_list)})"
        result_progress.add_task(f"[bold green]{fp['fp_name']}[/bold green]{ext_info}",
                                 total=100,
                                 completed=fp["percent"])

    result_table.add_row(Panel.fit(result_progress,
                                   title="[b]Fingerprint Matches Result",
                                   border_style="red", padding=(0, 5, 0, 1)))

    result_grid.add_row(Panel.fit(result_table, box=box.SIMPLE_HEAD, padding=(0, 0, 0, 10)))
    with Live(result_grid, refresh_per_second=3, vertical_overflow="visible"):
        pass


class SuperFingerprint:
    def __init__(self, superscan):
        self.superscan = superscan
        self.fpmode = self.superscan.get_option("fpmode")
        self.host = self.superscan.get_option("host")
        self.fingerprint_filter = self.init_fp_filters()  # 初始化指纹过滤器
        self.result = None

    def init_fp_filters(self):
        filters = {}
        if self.superscan.get_option("fptype"):
            filters.update({"type": self.superscan.get_option("fptype").split(",")})
        if self.superscan.get_option("fpplat"):
            filters.update({"platform": self.superscan.get_option("fpplat").split(",")})
        if self.superscan.get_option("fpmidd"):
            filters.update({"middleware": self.superscan.get_option("fpmidd").split(",")})
        if self.superscan.get_option("fplang"):
            filters.update({"language": self.superscan.get_option("fplang").split(",")})
        availableFilters(filters)
        return filters

    @timeit
    def start(self):
        """
        扫描入口

        :return:
        :rtype:
        """
        response = ''
        result = None
        with console.rConsole.status(formatString("正在尝试获取响应..."), spinner="point"):
            is_requesting = False
            while response == '':
                if not is_requesting:
                    try:
                        response = self.superscan.request.get("")
                        is_requesting = True
                    except Exception as e:
                        console.warning(f"获取响应失败 {repr(e)}")
                        break
        if response:
            console.info(f"获取到目标响应: {response.status_code}")

        with console.rConsole.status(formatString("正在识别目标指纹信息..."), spinner="point"):
            is_running = False
            while result is None:
                if not is_running:
                    try:
                        result = self.superscan.fpMatches(response=response,
                                                          mode=self.fpmode,
                                                          fp_filter=self.fingerprint_filter)
                        is_running = True
                    except Exception as e:
                        console.exception(repr(e))
                        break
        if result:
            console.debug(result)
            result = sorted(result, key=lambda k: k["percent"], reverse=True)
            show_result(result)

        return result
