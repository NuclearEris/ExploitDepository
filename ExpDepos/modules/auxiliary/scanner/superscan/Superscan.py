#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/12/16 20:55
"""
import difflib
from time import sleep
from rich import box
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.console import Console as rConsole
from rich.progress import Progress, TaskID

from ExpDepos.libs.core.base.ExploitBase import *


def get_file_ext(line: str) -> str:
    return line[line.rindex(".") + 1:]


def format_host(host: str) -> str:
    if not host.endswith("/"):
        host = host + "/"
    return host


def generate_table(columns: list, *args, **kwargs):
    if "min_width" not in kwargs:
        kwargs.update({"min_width": 120})
    if "highlight" not in kwargs:
        kwargs.update({"highlight": True})
    if "box" not in kwargs:
        kwargs.update({"box": box.ASCII})
    table = Table(*args, **kwargs)
    for column in columns:
        table.add_column(column)
    return table


def has_var(line):
    var = [".", "$VAR$", "%EXT%", "{ext}", "$DM$"]
    return [v for v in var if v in line]


def segment2text(segments):
    """
    转换rich到segment对象为text字符串

    @param segments: segment对象
    @type segments: Iterable[Segment]
    @return:
    @rtype:
    """
    if not segments:
        return ''
    text = "".join(
        segment.text
        for segment in segments
        if not segment.is_control
    )
    return text


class Superscan(ExploitBase):
    Name = "superscan"
    Author = "Castiel"
    Alias = "superscan"
    Category = EXP_CATEGORY.TOOLS.AIDE
    VulType = VUL_TYPE.OTHER
    Create_Date = '2021-12-16'
    Update_Date = '2021-12-16'
    Rank = 'Excellent'
    AppPowerLink = ''
    AppName = ''
    AppVersion = ''
    Desc = """一款综合扫描模块"""

    def __init__(self):
        super().__init__()
        self.default_extensions = ["htm", "html", "cshtml", "asp", "aspx", "ashx", "asmx", "php", "jsp", "do", "action"]
        self.default_archive_ext = ["rar", "zip", "7z", "tar", "gz", "iso"]
        self.action = None  # 扫描模块
        self.dic = None  # 扫描字典选项
        self.wordlist = None  # 自定义字典文件
        self.ext = None  # 自定义扩展名
        self.smart = True  # 启用智能扫描
        self.exclude_ext = None  # 排除的扩展名
        self.dic_path = env.Config.DATA_PATH + os.sep + "dics" + os.sep + "superscan" + os.sep  # 默认字典路径
        self.output_path = env.Config.DATA_PATH + os.sep + "output" + os.sep + "superscan" + os.sep  # 结果输出目录
        self.dir_dic = []  # 字典列表
        self.dir_scan_404_hash = {}  # 智能识别404页面信息
        self.domain = ""
        self.output = "Dirscan_output.log"
        self.counter = 0
        # 404 页面近似匹配度 如果随机请求不存在的页面返回非正常404响应，且页面近似匹配度大于该值则将该页面视为404 页面
        self._404_ratio = 0.6
        self.smart_req_sleep = 2  # 智能识别时候请求间隔，未开启云函数时候生效
        self.scf_test = False

    def _options(self):
        options = dict()
        options["action"] = OptString("dir", description="选择要使用的扫描模块", choices=["dir", "port", "domain", "fps"])
        options["dic"] = OptString("all", description="扫描字典选项 可选dir(仅目录)、file(仅文件)、all(目录和文件) 默认 all",
                                   choices=["dir", "file", "all"])
        options["wordlist"] = OptString("", description="手动指定位于/data/dics/superscan/下的字典文件, 多个使用','分隔")
        options["ext"] = OptString("", description="目录和文件扫描扩展，多个扩展名使用','分隔")
        options["smart"] = OptBoolean(True, description="开启智能扫描(适用于dir扫描模块)")
        options["exclude_ext"] = OptString("", description="需要排除的扩展名，多个扩展名使用','分隔")
        options["ports"] = OptString("", description="需要扫描的端口(多个端口使用','分隔, '-'标识连续端口号)")
        options["hostfile"] = OptString("", description="从文件读取host列表(每一行为一个IP或者IP段, '-'标识连续段IP地址)")
        options["fpmode"] = OptString("ALL", description="WEB指纹识别模式", choices=["ALL", "PASS", "AGGR", "EXP"])
        options["fptype"] = OptString("webApp,middleware,device,vulnerability", description="指定WEB指纹类型，多个使用','分隔")
        options["fpplat"] = OptString("", description="WEB指纹识别过滤器platform值，多个使用','分隔")
        options["fpmidd"] = OptString("", description="WEB指纹识别过滤器middleware值，多个使用','分隔")
        options["fplang"] = OptString("", description="WEB指纹识别过滤器language值，多个使用','分隔")
        options["noping"] = OptBoolean(False, description="跳过存活主机探测")
        options["noprobe"] = OptBoolean(False, description="端口扫描是否自动识别端口对应服务及web指纹信息(等于同时设置--nosv --noweb --nofp)")
        options["nosrv"] = OptBoolean(False, description="端口扫描是否自动进行服务识别")
        options["noweb"] = OptBoolean(False, description="端口扫描是否开启自动识别WEB标题")
        options["nofp"] = OptBoolean(False, description="端口扫描是否开启自动WEB指纹识别")
        options["output"] = OptString("Dirscan_output.log", description="扫描结果输出文件")
        options["thread"] = OptInteger(20, description="扫描线程数(默认: 20)")
        options["scftest"] = OptBoolean(False, description="使用临时云函数测试(开发调试使用)")
        return options

    def _verify(self):
        return self._exploit()

    def _exploit(self):
        self.init()
        result = []
        if self.action == "dir":
            result = self.dir_scan()
            self.result.success(f"目录扫描完成, 在 {self.counter} 次扫描中共找到 {result['total']} 条匹配。")
        if self.action == "port":
            result = self.port_scan()
        if self.action == "fps":
            result = self.fps_scan()
        return result

    def init(self):
        if self.get_option("scftest"):
            self.scf_test = True
        self.action = self.get_option("action")
        self.dic = self.get_option("dic")
        self.wordlist = self.get_option("wordlist")
        self.ext = self.get_option("ext").split(",")
        if len(self.ext) == 1 and self.ext[0] == '' and self.dic != 'all':
            self.dic = "dir"  # 如果未设置扩展名，则默认使用目录字典扫描
        self.smart = self.get_option("smart")
        if self.ext:  # 智能排除扩展名
            self.exclude_ext = set(self.default_extensions) - set(self.ext)

        self.output = self.get_option("output")

    def dir_scan(self):
        """
        目录扫描入口
        """
        host = self.get_option("host")
        if not host:
            raise ExploitValidationException("未指定需要扫描的目标URL")
        if "://" not in host:
            host = "http://" + host
        obj = urlparse(host)
        self.domain = obj.hostname
        self.output = "Dirscan_" + self.domain + "_output.log"
        # 初始化输出文件
        if os.path.exists(self.output_path + self.output):
            os.remove(self.output_path + self.output)
        self.ini_dir_dic()
        console.debug(f"字典准备完成，共: {len(self.dir_dic)} 条记录")
        # 启用多线程扫描
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return asyncio.get_event_loop().run_until_complete(self.async_dir_scan())

    def port_scan(self):
        """
        端口扫描入口

        @return:
        @rtype:
        """
        # scapy加载时候会有WARNING: No IPv4 address found on anpi1 ! 所以将SuperPort模块导入放到函数中
        result = []
        from SuperPort import SuperPort
        try:
            super_port = SuperPort(self)
            result = super_port.start()
            if result:
                ports_sum = sum(len(host_ports) for host_ports in result.values())
                self.result.success(f"端口扫描完成! 在 {len(result)} 个主机中共发现 {ports_sum} 个开放端口!", result)
        except ExpDeposException as e:
            self.result.fail(e.args[0])
        return result

    def fps_scan(self):
        """
        指纹扫描入口

        :return:
        :rtype:
        """
        result = []
        from SuperFingerprint import SuperFingerprint
        try:
            super_fps = SuperFingerprint(self)
            result = super_fps.start()
            if result:
                match_list = []
                for match in result:
                    match_list.append(f"{match['fp_name']} ([bold magenta]{match['percent']}%[/bold magenta])")
                self.result.success(f"指纹识别完成!", {"result": str(match_list)})
        except Exception as e:
            self.result.fail(e.args[0])
        return result

    def ini_dir_dic(self):
        """
        初始化目录字典
        """
        files = ["dirs.dic", "files.dic"]
        if self.dic == "dir":
            files = ["dirs.dic"]
        if self.dic == "file":
            files = ["files.dic"]
        if self.wordlist:
            files = self.wordlist.split(",")
        for dict_file in files:
            dic_path = self.dic_path + dict_file
            if not os.path.exists(dic_path):
                console.warning(f"找不到字典文件: {dic_path}")
                continue
            for line in open(dic_path, "r", encoding=get_encoding(dic_path)):
                if not line.startswith("/"):
                    line = "/" + line
                line = line.strip()
                line = line.replace("//", "/")

                if dict_file == "files.dic" and "." in line:
                    ext = get_file_ext(line)
                elif dict_file == "dirs.dic" and not line.endswith("/"):  # 如果是目录字典且不以'/'结尾则自动加上
                    line = line + "/"
                    ext = None
                else:
                    # 如果当前字典文件不是files.dic 并且line中不含'.' 则将该line视为目录，自动添加"/"
                    if not has_var(line) and not line.endswith("/"):
                        line = line + "/"
                    ext = None

                # 排除过滤的扩展文件
                if ext and ext in self.exclude_ext:
                    continue
                for file_ext in self.ext:
                    if not file_ext.startswith("."):
                        file_ext = "." + file_ext
                    self.dir_dic.append(line.replace('$VAR$', file_ext)
                                        .replace('$DM$', str(self.domain))
                                        .replace('%EXT%', file_ext)
                                        .replace('{ext}', file_ext)
                                        )
                # 添加常用压缩文件扩展字典
                if ext in self.default_archive_ext:
                    for archive_ext in self.default_archive_ext:
                        if ext != archive_ext:
                            self.dir_dic.append(line.replace(ext, archive_ext))
        # 去重并打乱顺序
        self.dir_dic = list(set(self.dir_dic))

    @asyncTimeit
    async def async_dir_scan(self):
        """
        多线程目录扫描
        """
        sem = asyncio.Semaphore(env.CliOptions.thread)

        async def aw_task(aw):
            async with sem:
                return await aw

        if not self.asyncRequest.useScf:
            console.warning("[yellow]当前未使用云函数代理请求, 建议开启云函数功能对抗WAF等相关安全产品.[/yellow]")

        # 初始化实时显示所需对象和参数
        scan_result = {"count": 0}
        self.counter = 0
        process_grid = Table.grid()
        result_table = generate_table(["#", "URL", "Status_Code"])
        progress = Progress()
        progress_task = progress.add_task(formatPgString(f"[green]正在扫描: {self.get_option('host')}[/green]"),
                                          total=len(self.dir_dic))
        process_grid.add_row(Panel.fit(result_table, box=box.SIMPLE_HEAD, title="Scanning Result",
                                       border_style="red", padding=(0, 0, 0, 10)))
        process_grid.add_row(progress)

        if self.smart:
            with console.rConsole.status(formatString("正在智能识别404页面..."), spinner="point"):
                await self.identify_404()  # 智能识别404 页面 减少误报
                if self.dir_scan_404_hash:
                    console.debug(f"智能识别到404 Hashes: {self.dir_scan_404_hash}")
        # 多线程初始化
        task_list = list()
        with Live(process_grid, refresh_per_second=4, vertical_overflow="visible"):
            for dic in self.dir_dic:
                result = self.send_request(dic, result_table, progress, progress_task, scan_result)
                if sys.version_info < (3, 7):
                    task = asyncio.ensure_future(aw_task(result))
                else:
                    task = asyncio.create_task(aw_task(result))
                task_list.append(task)
            await asyncio.gather(*task_list)
        return {"total": scan_result["count"]}

    async def identify_404(self):
        """
        智能识别404页面，这在某些网站找不到页面时候返回200状态时候比较实用

        @return:
        @rtype:
        """
        dir_str = randstr(random.choice(range(10, 20)))

        # 智能识别非正常404响应的文件请求
        if self.dic != "dir":
            file_404_hash = await self.identify_404_file()
            if file_404_hash:
                self.dir_scan_404_hash.update(file_404_hash)
        # 智能识别非正常404响应的目录请求
        response = await self.asyncRequest.get(dir_str + "/")
        if response:
            ratio = self.match_ratio(self.dir_scan_404_hash, response)
            # 如果与文件 404 响应没有近似匹配且响应状态码非404 则进入智能识别非正常404 目录请求函数
            if not ratio > self._404_ratio and response.status_code != 404:
                dir_404_hash = await self.identify_404_dir(response)
                if dir_404_hash:
                    self.dir_scan_404_hash.update(dir_404_hash)
        # 将首页hash也加入404 hash列表 某些404请求会重定向到首页
        response = await self.asyncRequest.get("")
        if response:
            ratio = self.match_ratio(self.dir_scan_404_hash, response)
            if not ratio > self._404_ratio:
                self.dir_scan_404_hash.update({"index": {"status_code": response.status_code,
                                                         "hash": response.md5sum,
                                                         "response": response}})

    async def identify_404_file(self, ext="", metadata=None):
        """
        智能识别非正常404页面的文件请求

        @param ext: 重复验证特定扩展名的文件
        @param metadata: 重复验证特定扩展名时候的基础数据
        @return: 404页面信息
        @rtype: dict
        """
        file_str = randstr(random.choice(range(5, 30)))
        result = {}
        # 先做一次随机请求或指定response作为对比基础
        if ext and metadata:
            repeat = "[yellow] 重复 [/yellow]"
            response = metadata["response"]
        else:
            response = await self.asyncRequest.get(file_str + "." + randstr(random.choice(range(3, 6)), letter=True)
                                                   if not ext else ext)
            repeat = ""
        if response:
            first_status_code = response.status_code
            first_hash = response.md5sum if not metadata else metadata["hash"]
            result = {"first": {"status_code": first_status_code, "hash": first_hash, "response": response}}
            # 再根据定义的文件扩展名做一次或者多次随机请求
            extensions = self.ext if not ext else [ext]
            if extensions:
                for ext in extensions:
                    if not self.asyncRequest.useScf:
                        sleep(self.smart_req_sleep)  # 每次请求间隔
                    console.debug(f"正在{repeat}识别 [yellow]{ext}[/yellow] 扩展")
                    file_str = randstr(random.choice(range(5, 30)))
                    response = await self.asyncRequest.get(file_str + "." + ext)
                    if first_status_code == 404 and response.status_code == 404:  # 随机请求能正常返回404
                        continue
                    if response.status_code != 404:  # 随机请求不能正常返回404
                        console.debug("识别到文件请求返回非正常404响应, 正在进一步识别...")
                        if response.md5sum == first_hash:  # 如果与第一次请求hash相等则将此hash作为非正常404页面hash
                            console.debug("[green]识别到文件请求返回非正常404响应体Hash相等![/green]")
                            continue
                        else:
                            console.debug("[yellow]识别到文件请求返回非正常404响应体Hash不等![/yellow]")
                            ratio = self.match_ratio(result, response)
                            if ratio > self._404_ratio:
                                console.debug(f"识别到随机请求相似度: {ratio}")
                                continue
                            else:
                                console.warning(f"[bold yellow]{ext} 扩展随机文件智能识别失败，随机请求相似度过低: [bold yellow]{ratio}")
                                result.update({ext: {"status_code": response.status_code,
                                                     "hash": response.md5sum,
                                                     "response": response}})
            # 对与第一次随机请求没有近似匹配对扩展做进一步针对性识别
            if len(result) > 1 and not repeat:
                for ext, data in result.items():
                    if ext == "first":
                        continue
                    repeat_result = await self.identify_404_file(ext, data)
                    if repeat_result and len(repeat_result) > 1:
                        console.warning("[yellow] 重复 [/yellow]识别 [yellow]{ext}[/yellow] 扩展失败")
                        continue
        return result

    async def identify_404_dir(self, response: Response):
        """
        智能识别非正常404页面的目录请求

        @param response: 随机目录请求响应对象
        @type response: Response
        @return: 404页面信息
        @rtype: dict
        """
        first_status_code = response.status_code
        first_hash = response.md5sum
        result = {"first": {"status_code": first_status_code, "hash": first_hash, "response": response}}
        for times in range(3):
            if not self.asyncRequest.useScf:
                sleep(self.smart_req_sleep)  # 每次请求间隔
            dir_str = randstr(random.choice(range(10, 20)))
            response = await self.asyncRequest.get(dir_str + "/")
            if response.status_code != 404:  # 随机请求不能正常返回404
                console.debug("识别到目录请求返回非正常404响应, 正在进一步识别...")
                if response.md5sum == first_hash:  # 如果与第一次请求hash相等则将此hash作为非正常404页面hash
                    console.debug("[green]识别到目录请求返回非正常404响应体Hash相等![/green]")
                    continue
                else:
                    console.debug("[yellow]识别到目录请求返回非正常404响应体Hash不等![/yellow]")
                    ratio = self.match_ratio(result, response)
                    if ratio > self._404_ratio:
                        console.debug(f"识别到随机请求相似度: {ratio}")
                        continue
                    else:
                        console.warning(f"随机目录智能识别失败，随机请求相似度过低: [bold yellow]{ratio}")
                        result.update({"dir": {"status_code": response.status_code,
                                               "hash": response.md5sum,
                                               "response": response}})
        return result

    def match_ratio(self, result: dict, response: Response):
        """
        计算当前响应体是否与之前所有响应体近似匹配

        @param result: 之前请求的所有响应体字典
        @type result: dict
        @param response: 当前请求响应体
        @type response: Response
        @return: 返回匹配度平均值
        @rtype: float
        """
        times = 0
        ratio_total = 0
        if result:
            for key, value in result.items():
                times += 1
                # 相似度匹配的前提是响应的状态吗一致或者是302跳转
                if value["status_code"] == response.status_code or response.status_code == 302:
                    sequence = difflib.SequenceMatcher(None, value["response"].text, response.text)
                    ratio = sequence.ratio()
                    if ratio > self._404_ratio:  # 如果找到近似匹配则直接返回
                        return ratio
                    ratio_total += ratio
            return ratio_total / times
        return 0.0

    async def send_request(self, dic, result_table, progress, progress_task, result):
        """
        发送扫描请求

        @param dic: 请求URL
        @type dic: str
        @param result_table: 扫描结果表格
        @type result_table: Table
        @param progress: 扫描进度条对象
        @type progress: Progress
        @param progress_task: 扫描进度条
        @type progress_task: TaskID
        @param result: 扫描结果集
        @type result: dict
        @return:
        @rtype:
        """
        progress.update(progress_task, advance=1)
        self.counter += 1
        try:
            self.asyncRequest.set_progress(progress)
            response = await self.asyncRequest.get(dic)
            r = await self.asyncRequest.get(dic)
            if self.url_is_exists(response):
                result.update({"count": result["count"] + 1})
                result_table.add_row(str(result["count"]),
                                     f"[red]{self.get_option('host').strip('/') + dic}[/red]",
                                     f"[yellow]{response.status_code}[yellow]")
                # await self.write_output(f"{self.get_option('host').strip('/') + dic}\t\t{response.status_code}\n")
                await self.write_output(result_table)
        except Exception as e:
            progress.console.log(f"{dic} 扫描异常: {repr(e)}")
            return False
        return True

    def url_is_exists(self, response: Response):
        """
        验证请求的URL是否存在

        @param response: 请求响应体对象
        @type response: Response
        @return: 请求是否存在
        @rtype: bool
        """
        if response.status_code == 404 or response.status_code == 400:  # 如果请求响应正常404或400 则直接返回 False
            return False
        if self.dir_scan_404_hash:  # 将响应体与智能识别的404页面信息进行相似度匹配，如果匹配到相似则返回 False
            ratio = self.match_ratio(self.dir_scan_404_hash, response)
            if ratio > self._404_ratio:
                return False
        return True

    async def write_output(self, result_table):
        consoles = rConsole()
        result_segment = consoles.render(result_table)
        with open(self.output_path + self.output, mode="w", encoding="UTF-8") as output:
            output.write(segment2text(result_segment))
