#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2022/4/6 10:23
"""
import cmd
import copy
import difflib
from ExpDepos.libs.core.base.ExploitBase import *
from ExpDepos.libs.core.common.Enums import ENUMS
from ExpDepos.libs.core.common.ExpPrompt import ExpPrompt
from ExpDepos.libs.core.common.Common import env

REPETITION_RATIO = 0.6  # 指纹重复相似度判定值


def _show_value(name, value):
    console.info(f"[bold green]{name}[/bold green] => [bold yellow]{value}[/bold yellow]")


def complete_process(text, line, begidx, endidx, shortList):
    if text or line:
        currentMakeup = line[line.rindex(" ") + 1:]
        offs = len(currentMakeup) - len(text)
        # 当候选列表中的值为大写且输入值为小写时候自动将输入值转换为大写 反之亦然
        lists = get_list(offs, shortList, currentMakeup)
        return lists
    else:
        return shortList


def get_list(offs, short_list, current_mark):
    lists = []
    for item in short_list:
        if len(item) < offs:  # 忽略掉长度小于offs值的条目，防止后续取值报错
            continue
        if (item.isupper() or item[offs:][0].isupper()) and current_mark and current_mark[-1].islower():  # 兼容小写输入
            current_mark = current_mark.upper()
        if item.startswith(current_mark) or item.upper().startswith(current_mark):
            lists.append(item[offs:])
    return lists


def is_similar(name, description):
    """
    通过指纹名称和描述校验是否有已存在或者有相似度较高的指纹

    :param name: 指纹名称
    :type name: str
    :param description: 指纹描述
    :type description: str
    :return:
    :rtype:
    """
    similar_list = []
    sorted_similar_list = []
    for fp in env.fps:
        sequence_name = difflib.SequenceMatcher(None, name.lower(), fp.name.lower())
        sequence_desc = difflib.SequenceMatcher(None, description.lower(),
                                                '' if not fp.description else fp.description.lower())
        sequence_name_ratio = sequence_name.ratio()
        sequence_desc_ratio = sequence_desc.ratio()
        if sequence_name_ratio > REPETITION_RATIO or sequence_desc_ratio > REPETITION_RATIO:
            # ratio 选择较大的一个
            ratio = sequence_name_ratio if sequence_name_ratio > sequence_desc_ratio else sequence_desc_ratio
            similar_list.append({"ratio": ratio, "obj": fp})
    if similar_list:
        sorted_similar_list = sorted(similar_list, key=lambda k: k["ratio"], reverse=True)
        sorted_similar_list = [fp["obj"] for fp in sorted_similar_list]
    return sorted_similar_list


def _get_fp_by_name(choose_name, fps: list = None) -> [Fingerprint, None]:
    if not fps:
        fps = env.fps
    for fp in fps:
        if fp.name == choose_name:
            return fp
    return None


def _get_exp_by_name(exp_name):
    for exploit in env.modules:
        if exploit['Name'] == exp_name or exploit['Alias'] == exp_name:
            if 'module' in exploit and exploit['module']:
                return exploit['module'].SPEC
    return ''


def build_list_str(lists):
    i = 0
    list_str = ''
    for item in lists:
        list_str += f"{i}\t{item}\n"
        i += 1
    return list_str


def _get_index(collection: [list, dict]) -> [int, str]:
    """
    获取编辑内容索引值

    :param collection: 编辑内容集合
    :type collection: [list, dict]
    :return:
    :rtype:
    """
    index = ''
    if isinstance(collection, list):
        show_str = build_list_str(collection)
        while index == '':
            index = console.input(f"\n\n{show_str}\n请选择要编辑的内容: ", normal=True)
            try:
                index = int(index)
                value = collection[index]
                if not value:
                    console.error(f"编辑内容选择错误: {index}, 请重新选择!")
                    index = ''
            except Exception as e:
                console.error(f"编辑内容选择错误: {index}, 请重新选择!")
                index = ''
    if isinstance(collection, dict):
        index_list = list(collection.keys())
        index_list_with_value = [f"{item}{f'({collection.get(item)})' if collection.get(item) else ''}"
                                 for item in index_list]
        show_str = build_list_str(index_list_with_value)
        while index == '':
            index = console.input(f"\n\n{show_str}\n请选择要编辑的内容: ", normal=True)
            try:
                index = index_list[int(index)]
            except Exception as e:
                console.error(f"编辑内容选择错误: {index}, 请重新选择!")
                index = ''
    return index


def _available_index(index, collection):
    """
    校验编辑项目索引值

    :param index: 索引值
    :type index: [int, str]
    :param collection: 编辑内容集合
    :type collection: [list, dict]
    :return:
    :rtype:
    """
    try:
        if isinstance(collection, list):
            value = collection[int(index)]
            if value:
                return True
        if isinstance(collection, dict):
            return index in collection
    except Exception as e:
        return False
    return False


def _available_filter(filter_item_value, value_optional):
    """
    校验过滤属性值

    :param filter_item_value: 需要验证的属性值
    :type filter_item_value: list
    :param value_optional: 验证列表
    :type value_optional: list
    :return:
    :rtype:
    """
    fail_list = []
    for item_value in filter_item_value:
        if item_value not in value_optional:
            fail_list.append(item_value)
    return fail_list


def _sub_desc(description):
    """
    截取指纹描述信息

    :param description:
    :type description:
    :return:
    :rtype:
    """
    if len(description) <= 100:
        return description
    desc = ''
    if "." in description:
        desc = description[:description.index(".")]
        desc += "..."
    if "。" in description:
        desc = description[:description.index("。")]
        desc += "..."
    if "..." not in desc:
        desc = description[:100]
        desc += "..."
    return desc


class AddFps(ExploitBase):
    Name = "add fingerprints"
    Author = "Castiel"
    Alias = "addfps"
    Category = EXP_CATEGORY.TOOLS.AIDE
    VulType = VUL_TYPE.OTHER
    Create_Date = '2022-04-06'
    Update_Date = '2022-04-06'
    Rank = RANK.Normal
    AppPowerLink = ''
    AppName = ''
    AppVersion = ''
    Desc = """指纹添加向导"""

    def __init__(self):
        self.default_fingerprint = {}
        super().__init__()

    def _init(self) -> bool:
        self.default_fingerprint = {
            "name": "example_fp",
            "author": "nobody",
            "version": "1.0",
            "type": "example",
            "logic": "or",
            "description": "指纹描述信息",
            "website": "",
            "regByExp": "",
            "filters": {},
            "matches": [],
            "sets": {}
        }
        return True

    def _verify(self):
        return self._exploit()

    def _exploit(self):
        console.print("\n欢迎使用指纹添加向导, 请根据提示填写指纹基本信息!\n")
        name = ''

        # 指纹名称信息
        while name == '':
            name = console.input("请输入指纹名称: ", normal=True)
        self.default_fingerprint.update({"name": name})
        _show_value("name", name)

        # 指纹描述信息
        description = ''
        while description == '':
            description = console.input("请输入指纹描述: ", normal=True)
        self.default_fingerprint.update({"description": description})
        _show_value("description", description)

        # 根据指纹名称和描述查询是否有重复或者近似重复到指纹
        similar = is_similar(name, description)
        if similar:
            repetition_list = [f"{fp.name}" \
                               f"{f'([bold magenta]{_sub_desc(fp.description)}[/bold magenta])' if fp.description else ''}"
                               for fp in similar]
            repetition_list_choose = [fp.name for fp in similar]
            repetition_str = build_list_str(repetition_list)
            choose_name = ''
            while choose_name == '':
                choose = console.input(
                    f"\n\n{repetition_str}\n找到以上 {len(similar)} 个相似指纹, 若需要更新以上指纹请输入对应编号,继续添加新指纹请按回车: "
                    , normal=True)
                if choose:
                    try:
                        choose_name = repetition_list_choose[int(choose)]
                        fp = _get_fp_by_name(choose_name, similar)
                        self.default_fingerprint.update(fp.todict())
                        console.print(self.default_fingerprint)
                        AddConsole(self.default_fingerprint, is_save=True).cmdloop()  # 加载已存在的指纹信息，初始化为已保存状态
                        self.result.success("指纹注册成功!", self.default_fingerprint)
                        return
                    except Exception as e:
                        console.exception(e)
                        console.error(f"需要更新的指纹选择错误: {choose}, 请重新选择!")
                else:
                    break

        # 指纹作者信息
        author = console.input(f"指纹作者({self.default_fingerprint.get('author')}), 多个请使用 ',' 分隔: ", normal=True)
        if not author:
            author = self.default_fingerprint.get("author")
        if isinstance(author, str):
            author = author.split(",")
        self.default_fingerprint.update({"author": author})
        _show_value("author", author)

        # 指纹版本信息
        version = console.input(f"指纹版本信息({self.default_fingerprint.get('version')}): ", normal=True)
        if not version:
            version = self.default_fingerprint.get('version')
        _show_value("version", version)

        # 指纹类型信息
        t_list = FINGERPRINT.FP_TYPE.__dict__
        type_lists = []
        for t in t_list:
            if not t.startswith("__") and t.isupper():
                type_lists.append(getattr(FINGERPRINT.FP_TYPE, t))
        type_lists_str = build_list_str(type_lists)
        fp_type = ''
        while fp_type == '':
            type_int = console.input(f"\n\n{type_lists_str}\n选择指纹类型 [green]platform[/green](系统平台)、"
                                     f"[green]middleware[/green](中间件)、"
                                     f"[green]device[/green](设备)、[green]webApp[/green](web应用)、"
                                     f"[green]vulnerability[/green](漏洞)、[green]other[/green](其他): ", normal=True)
            if type_int:
                try:
                    type_int = int(type_int)
                    fp_type = type_lists[type_int]
                except Exception as e:
                    console.error(f"指纹类型选择错误: {type_int}, 请重新选择!")
            else:
                fp_type = FINGERPRINT.FP_TYPE.WEBAPP
        self.default_fingerprint.update({"type": fp_type})
        _show_value("type", fp_type)

        # 指纹匹配逻辑
        logic = console.input(f"指纹匹配项逻辑({self.default_fingerprint.get('logic')}): ", normal=True)
        if not logic:
            logic = self.default_fingerprint.get('logic')
        self.default_fingerprint.update({"logic": logic})
        _show_value("logic", logic)

        # 厂商地址
        website = console.input("厂商WEB网站或连接地址: ", normal=True)
        if website:
            self.default_fingerprint.update({"website": website})
            _show_value("website", website)

        AddConsole(self.default_fingerprint).cmdloop()
        self.result.success("指纹注册成功!", self.default_fingerprint)


class AddConsole(cmd.Cmd):
    prompt = "[bold magenta]AddFps>[/bold magenta] "
    intro = """
\n指纹基本信息已完成,请使用以下命令添加 [bold magenta]matches、filters、sets[/bold magenta] 信息, 或者使用其他命令完善指纹配置。\n
[bold green] add [/bold green]添加 [bold magenta]matches、filters、sets[/bold magenta] \n
[bold green] edit [/bold green]编辑 [bold magenta]matches、filters、sets[/bold magenta] \n
[bold green] set [/bold green]设置指纹基本信息\n
[bold green] show [/bold green]查看当前指纹信息\n
[bold green] save [/bold green]注册当前指纹信息到文件\n
[bold green] exit [/bold green]退出指纹编写\n
"""

    def __init__(self, fp: dict, is_save=False):
        self.fp = fp
        self.fp_copy = copy.deepcopy(fp)  # 创建指纹副本 用于对比指纹属性是否修改
        self.is_save = is_save  # 标识指纹信息是否已保存
        self.add_complete_list = ["matches", "filters", "sets"]
        self.set_complete_list = [key for key in self.fp.keys() if key not in self.add_complete_list]
        super(AddConsole, self).__init__()

    def do_add(self, args):
        try:
            if args not in self.add_complete_list:
                console.error(f"无效的add指令{args}, 只允许 {self.add_complete_list}")
                return
            if args == "matches":
                self._add_matches()
            if args == "filters":
                self._add_filters()
            if args == "sets":
                self._add_sets()
        except KeyboardInterrupt as e:
            console.info("已终止添加!")

    def do_edit(self, args):
        try:
            index = None
            if len(args.split(" ")) > 1:
                try:
                    args, index = args.split(" ")
                except ValueError as e:
                    console.error(f"edit指令错误! edit用法: edit attributes [index]")
            if args not in self.add_complete_list:
                console.error(f"无效的edit指令{args}, 只允许 {self.add_complete_list}")
                return
            if args == "matches":
                self._edit_matches(index=index)
            if args == "filters":
                self._edit_filters(index=index)
            if args == "sets":
                self._edit_sets(index=index)
        except KeyboardInterrupt as e:
            console.info("已终止编辑!")

    def _edit_matches(self, index=None):
        """
        编辑匹配项

        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if not self.fp.get("matches"):
            console.warning("当前指纹还未添加匹配项, 请先添加匹配项!")
            self._add_matches()
            return
        if not index:
            index = _get_index(self.fp.get("matches"))
        if not _available_index(index, self.fp.get("matches")):
            console.error(f"需要编辑的项目索引错误! 请确认索引值 [bold yellow]{index}[/bold yellow] 是否存在!")
            return
        self._add_matches(index=index)

    def _edit_filters(self, index=None):
        """
        编辑过滤属性

        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if not self.fp.get("filters"):
            console.warning("当前指纹还未添加过滤属性, 请先添加过滤属性!")
            self._add_filters()
            return
        if not index:
            index = _get_index(self.fp.get("filters"))
        if not _available_index(index, self.fp.get("filters")):
            console.error(f"需要编辑的项目索引错误! 请确认索引值 [bold yellow]{index}[/bold yellow] 是否存在!")
            return
        self._add_filters(index=index)

    def _edit_sets(self, index=None):
        """
        编辑请求配置属性

        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if not self.fp.get("sets"):
            console.warning("当前指纹还未添加请求配置, 请先添加请求配置!")
            self._add_sets()
            return
        if not index:
            index = _get_index(self.fp.get("sets"))
        if not _available_index(index, self.fp.get("sets")):
            console.error(f"需要编辑的项目索引错误! 请确认索引值 [bold yellow]{index}[/bold yellow] 是否存在!")
            return
        self._add_sets(index=index)

    def _add_sets(self, default=None, index=None):
        """
        添加主动匹配时的请求设置

        :param default: 默认值(如果提供后续值会值该值基础上增加或更新)
        :type default: dict
        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if not default:
            sets = dict()
        else:
            sets = default
        sets_list = ["headers", "cookies", "params", "data"]
        sets_str = build_list_str(sets_list)
        sets_item = ''
        if index:
            sets_item = index
        while sets_item == '':
            sets_item_int = console.input(f"\n\n{sets_str}\n请选择需要设置的HTTP请求项,"
                                          f" [bold green]headers[/bold green](http头)、"
                                          f"[bold green]cookies[/bold green](cookie)、"
                                          f"[bold green]params[/bold green](GET参数)、"
                                          f"[bold green]data[/bold green](POST参数): ", normal=True)
            try:
                sets_item = sets_list[int(sets_item_int)]
            except Exception as e:
                console.error(f"HTTP请求项选择错误: {sets_item_int}, 请重新选择!")
        set_item_value = ''
        while set_item_value == '':
            set_item_value = console.input(f"请输入 [bold green]{sets_item}[/bold green] 的值, "
                                           f"属性名与属性值请使用 '=' 分隔, 多个属性之间使用 ',' 分隔: ", normal=True)
            if set_item_value:
                values = set_item_value.split(",")
                for value in values:
                    if "=" not in value:
                        console.error(f"{value} 值设置错误! 缺少'='分隔!")
                        set_item_value = ''
                        break
                    try:
                        key, val = value.split("=")
                    except ValueError as e:
                        console.error(f"{value} 值设置错误! 过多的'='分隔?")
                    set_item_value = {key: val}
                    if sets_item in sets:
                        sets[sets_item].update(set_item_value)
                    else:
                        sets[sets_item] = set_item_value
        continue_add = ''
        while continue_add.lower() not in ["y", "n", "yes", "no"]:
            continue_add = console.input("当前已完成一个sets设置, 是否继续在该指纹中新增其他请求属性？(no): ", normal=True)
            if not continue_add:
                continue_add = "no"
        if continue_add in ["y", "yes"]:
            self._add_sets(default=sets, index=index)
        else:
            console.debug(sets)
            self.fp["sets"].update(sets)

    def _add_filters(self, default=None, index=None):
        """
        添加指纹过滤属性

        :param default: 默认值(如果提供后续值会值该值基础上增加或更新)
        :type default: dict
        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if not default:
            filters = dict()
        else:
            filters = default
        filter_list = ["platform", "middleware", "language"]
        fileter_str = build_list_str(filter_list)
        fileter_item = ''
        if index:
            fileter_item = index
        while fileter_item == '':
            fileter_item_int = console.input(f"\n\n{fileter_str}\n请选择要添加的指纹过滤属性类型, "
                                             f"[bold green]platform[/bold green](系统平台)、"
                                             f"[bold green]middleware[/bold green](中间件)、"
                                             f"[bold green]language[/bold green](脚本语言): ", normal=True)
            try:
                fileter_item = filter_list[int(fileter_item_int)]
            except Exception as e:
                console.error(f"指纹过滤属性类型选择错误: {fileter_item_int}, 请重新选择!")
        filter_item_value = ''
        value_optional = getattr(ENUMS, "SCRIPT_LANGUAGE" if fileter_item == 'language' else fileter_item.upper(), None)
        while filter_item_value == '':
            filter_item_value = console.input(f"请输入 [bold green]{fileter_item}[/bold green] 属性值"
                                              f"{', 可选' + str(value_optional) if value_optional else ''},"
                                              f" 多个请使用 ',' 分隔: ", normal=True)
            if filter_item_value:
                filter_item_value = filter_item_value.split(",")
                available = _available_filter(filter_item_value, value_optional)
                if available:
                    console.error(f"错误的过滤属性值: {available}, 请重新输入!")
                    filter_item_value = ''
        _show_value(fileter_item, filter_item_value)
        filters.update({fileter_item: filter_item_value})
        continue_add = ''
        while continue_add.lower() not in ["y", "n", "yes", "no"]:
            continue_add = console.input("当前已完成一个fileter设置, 是否继续在该指纹中新增其他过滤属性？(no): ", normal=True)
            if not continue_add:
                continue_add = "no"
        if continue_add in ["y", "yes"]:
            self._add_filters(default=filters, index=index)
        else:
            console.debug(filters)
            self.fp["filters"].update(filters)

    def _add_matches(self, index=None):
        """
        添加指纹匹配项

        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        match_mode = ''
        modes = ["Aggressive", "Passive"]
        mod_str = build_list_str(modes)
        while match_mode == '':
            mod_int = console.input(f"\n\n{mod_str}\n请选择匹配模式, [bold green]Aggressive[/bold green](主动模式)、"
                                    f"[bold green]Passive[/bold green](被动模式): ", normal=True)
            try:
                match_mode = modes[int(mod_int)]
            except Exception as e:
                console.error(f"匹配模式选择错误: {mod_int}, 请重新选择!")
        if match_mode == "Aggressive":
            self._add_aggr_match(index=index)
        if match_mode == "Passive":
            self._add_pass_match(index=index)

    def _add_aggr_match(self, index=None):
        """
        添加主动匹配项中的url

        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        match = dict()
        url = ''
        while url == '':
            url = console.input("请输入主动匹配模式请求的URL地址: ", normal=True)
        status = console.input("URL默认响应状态码(200): ", normal=True)
        if not status:
            status = 200
        match.update({"url": url, "status": status})
        _show_value("url", url)
        self._add_pass_match(default=match, index=index)

    def _add_pass_match(self, default=None, index=None):
        """
        添加被动匹配项中的匹配区域

        :param default: 默认值(如果提供后续值会值该值基础上增加或更新)
        :type default: dict
        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if default is None:
            match = dict()
        else:
            match = default
        positions = ["text", "headers"]
        search_in = ''
        position_str = build_list_str(positions)
        while search_in == '':
            search_in_int = console.input(f"\n\n{position_str}\n请选择匹配区域, "
                                          f"[bold green]text[/bold green](在http响应体中匹配)、"
                                          f"[bold green]headers[/bold green](在http响应头中匹配): ", normal=True)
            try:
                search_in = positions[int(search_in_int)]
            except Exception as e:
                console.error(f"匹配区域选择错误: {search_in_int}, 请重新选择!")
        if search_in == "headers":
            header_in = console.input("如果需要在具体响应头中匹配(例如: headers[Set-cookie],"
                                      " 不区分大小写)，请输入具体header头值(None): ", normal=True)
            if header_in:
                search_in = f"headers[{header_in}]"
        match.update({"search": search_in})
        _show_value("search", search_in)
        self._add_match_item(default=match, index=index)

    def _add_match_item(self, default=None, index=None):
        """
        添加匹配值

        :param default: 默认值(如果提供后续值会值该值基础上增加或更新)
        :type default: dict
        :param index: 需要编辑的特定项索引
        :type index: [int, str]
        :return:
        :rtype:
        """
        if default is None:
            match = dict()
        else:
            match = default
        match_items = ["keyword", "regex", "hash", "md5"]
        item_str = build_list_str(match_items)
        item = ''
        item_value = ''
        while item == '':
            item_int = console.input(f"\n\n{item_str}\n请选择匹配方式, [bold green]keyword[/bold green](关键词匹配)、"
                                     f"[bold green]regex[/bold green](正则匹配)、"
                                     f"[bold green]hash[/bold green](url mmh3值匹配)、"
                                     f"[bold green]md5[/bold green](url md5值匹配): ", normal=True)
            try:
                item = match_items[int(item_int)]
            except Exception as e:
                console.error(f"错误的匹配方式: {item_int}, 请重新选择!")
        while item_value == '':
            item_value = console.input(f"请输入{item}方式的匹配值(多个关键词匹配可使用"
                                       f" '<||>(逻辑或)' 或 '<&&>(逻辑与)' 进行逻辑匹配): ", normal=True)
            if item == "hash":
                try:
                    item_value = int(item_value)
                except Exception as e:
                    console.error(f"hash匹配值错误! 无法将 {item_value} 转换为int类型!")
                    item_value = ''
        _show_value(item, item_value)
        if item == "regex":
            offset = console.input(f"请输入正则匹配子组索引值(1): ", normal=True)
            if not offset:
                offset = 1
            match.update({"offset": offset})
        aim = console.input("如果需要将匹配结果存入返回集合的特定键中请输入该键名(None): ", normal=True)
        if aim:
            match.update({"aim": aim})
        match.update({item: item_value})
        continue_add = ''
        while continue_add.lower() not in ["y", "n", "yes", "no"]:
            continue_add = console.input("当前已完成一个match设置, 是否继续在该match中新增其他匹配方式？(no): ", normal=True)
            if not continue_add:
                continue_add = "no"
        if continue_add in ["y", "yes"]:
            self._add_match_item(default=match, index=index)
        else:
            console.debug(match)
            if not index:
                self.fp["matches"].append(match)
            else:
                self.fp["matches"][int(index)] = match

    def _bind_exploit(self):
        """
        绑定指纹到exploit模块

        :return:
        :rtype:
        """
        # 指纹对应Exp
        exp_spec = ''
        while exp_spec == '':
            exp_name = console.input("如果需将该指纹绑定到指定的 [bold green]Exploit[/bold green] 模块, 请输入模块名称或别名(None): ",
                                     normal=True)
            if not exp_name:
                break
            exp_spec = _get_exp_by_name(exp_name)
            if not exp_spec:
                console.warning(f"无法找到模块 {exp_name}, 请确认模块名称或别名是否正确!")
                exp_spec = ''
        if exp_spec:
            _show_value("regByExp", exp_spec)
        self.fp.update({"regByExp": exp_spec})

    def _is_changed(self):
        """
        校验指纹信息是否已更改

        :return:
        :rtype:
        """
        return self.fp != self.fp_copy

    def complete_add(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.add_complete_list)

    def complete_edit(self, text, line, begidx, endidx):
        return self.complete_add(text, line, begidx, endidx)

    def do_set(self, args):
        """
        设置基本属性

        :param args: 基本属性名
        :type args: str
        :return:
        :rtype:
        """
        if not args:
            console.error(f"请输入需要设置的属性名和属性值! 可选属性: {self.set_complete_list}")
            return
        args = cli2args(args.split())
        if args[0] not in self.set_complete_list:
            console.error(f"属性 [bold green]{args[0]}[/bold green] 错误, 可选范围: {self.set_complete_list}")
            return
        if len(args) <= 1:
            console.error(f"请输入属性 [bold green]{args[0]}[/bold green] 的值!")
            return
        name, value = args
        self.fp.update({name: value})

    def complete_set(self, text, line, begidx, endidx):
        return complete_process(text, line, begidx, endidx, self.set_complete_list)

    def do_show(self, args):
        console.info(self.fp)

    def do_save(self, args):
        try:
            self._bind_exploit()
            register(self.fp)
            self.is_save = True
            self.fp_copy = copy.deepcopy(self.fp)   # 保存之后将指纹当前状态深拷贝给 fp_copy
            console.info("指纹注册成功!")
        except KeyboardInterrupt as e:
            return

    def do_exit(self, args):
        try:
            if not self.is_save or self._is_changed():
                go_save = ''
                while go_save.lower() not in ["y", "n", "yes", "no"]:
                    if self.is_save and not self._is_changed():
                        break
                    go_save = console.input("当前指纹已修改但未保存, 保存后再退出？(yes): ", normal=True)
                    if go_save.lower() not in ["n", "no"]:
                        self.do_save("")
        except KeyboardInterrupt as e:
            return
        return True

    def do_NULL(self, arg):
        console.print("")

    def cmdloop(self, intro=None):
        """
        重载 cmdloop 改用rich.prompt

        :param intro:
        :return:
        """
        self.preloop()
        if self.use_rawinput and self.completekey:
            try:
                import readline
                self.old_completer = readline.get_completer()
                readline.set_completer(self.complete)
                readline.parse_and_bind(self.completekey + ": complete")
            except ImportError:
                pass
        try:
            if intro is not None:
                self.intro = intro
            if self.intro:
                # self.stdout.write(str(self.intro) + "\n")
                console.print(self.intro)
            stop = None
            while not stop:
                if self.cmdqueue:
                    line = self.cmdqueue.pop(0)
                else:
                    if self.use_rawinput:
                        try:
                            # 改用 ExpPrompt.ask
                            line = ExpPrompt.ask(self.prompt)
                        except KeyboardInterrupt:
                            line = 'NULL'
                        except EOFError:
                            line = 'EOF'
                    else:
                        self.stdout.write(self.prompt)
                        self.stdout.flush()
                        line = self.stdin.readline()
                        if not len(line):
                            line = 'EOF'
                        else:
                            line = line.rstrip('\r\n')
                try:
                    # 再循环内捕获异常 防止发生异常后退出交互式shell
                    line = self.precmd(line)
                    stop = self.onecmd(line)
                    stop = self.postcmd(stop, line)
                except Exception as e:
                    console.exception(e.args[0])
            self.postloop()
        finally:
            if self.use_rawinput and self.completekey:
                try:
                    import readline
                    readline.set_completer(self.old_completer)
                except ImportError:
                    pass
