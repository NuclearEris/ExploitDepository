#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/10 11:23
"""
import asyncio
import sys

from .TDOABase import *


class Test(TdoaBase):
    """
    Exploit模块实现,用户按照如下规则编写自己的Exploit
    1.  模块基本信息属性使用全大写或首字母大写方式(ex:NAME or Name or Create_Date)
        属性值若有多个可以使用列表(ex:Author = ["author1", "another author"])
        描述信息Description和Desc支持Markdown语法
        除下列默认属性外，用户可自定义其他信息属性
    """
    Name = 'Test Exploit'  # exp名称
    Author = 'Castiel'  # 编写作者
    Create_Date = '2021-07-01'  # exp编写日期
    Update_Date = '2021-07-01'  # exp更新日期
    Rank = 'Excellent'  # exp效果(可选：Excellent Great Good Normal Average # Low Manual)
    AppPowerLink = 'https://www.tongda2000.com/'  # 漏洞厂商主页地址
    AppName = 'TD_OA'  # 漏洞应用名称
    AppVersion = '3.x - 11.6'  # 漏洞影响版本
    References = ['https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2017/MS17-010',
                  'https://nvd.nist.gov/vuln/detail/CVE-XXX-XXX',
                  'https://github.com/xxx/xxx']
    Desc = """
## 漏洞简要描述支持Markdown语法
`通达OA` 任意用户登录漏洞
    """
    Description = """
# Exploit文档支持Markdown语法
## This is an h2

Rich can do a pretty *decent* job of rendering markdown.

1. This is a list item
2. This is another list item
        """

    def _options(self):
        options = dict()
        options["UserName"] = OptString("", description="系统用户名", require=True)
        options["Password"] = OptString("", description="密码", require=True)
        options["notRequire"] = OptString("", description="测试非必须选项")
        return options

    @timeit
    def _testRequest(self, times):
        """
        测试同步请求性能

        :param times: 测试请求次数
        :return:
        """
        for x in range(times):
            response = self.request.get("/test.asp")
            assert response.status_code == 200

    async def _request(self):
        response = await self.asyncRequest.get("/test.asp")
        assert response.status_code == 200

    @asyncTimeit
    async def _testAsyncRequest(self, times):
        """
        测试异步请求性能

        :param times: 测试请求次数
        :return:
        """
        task_list = list()
        for x in range(times):
            req = self._request()
            if (sys.version_info.major, sys.version_info.micro) < (3, 7):
                task = asyncio.ensure_future(req)
            else:
                task = asyncio.create_task(req)
            task_list.append(task)
        await asyncio.gather(*task_list)

    def _test(self, times=10, isAsync=True):
        """
        性能测试，本方法主要测试httpx的同步和异步请求性能

        :param times: 测试请求次数
        :param isAsync:
        :return:
        """
        # 同步请求接口self.request测试

        # response = self.request.post("/test.asp", data={"test": "123456"},
        #                              files={"files":
        #                                     ("cookie.txt", bytes("hello file contents".encode("utf-8")))
        #                                     }
        #                              )
        headers = {"referer": "changed referer"}
        response = self.request.get("/test.asp", headers=headers)
        console.debug("response status:{0}".format(response.status_code))
        console.debug("response hash:{}".format(response.hash))
        console.debug("response md5sum:{}".format(response.md5sum))
        console.debug("response text:{}".format(response.text))
        console.debug("response encode: {}".format(response.get_encoding()))
        console.debug("response contains: {}".format(response.contains("rar.exe")))
        console.debug("response bcontains: {}".format(response.bcontains(b"wwwroot")))
        console.debug("response bcontains with str: {}".format(response.bcontains("wwwroot")))
        console.debug("response search: {}".format(response.search("hello+word")))
        console.debug("response server: {}".format(response.server))

        # if isAsync:
        #     asyncio.run(self._testAsyncRequest(times))
        # else:
        #     self._testRequest(times)

    def _verify(self):
        # 性能测试
        self._test(times=10)

        self.result.fail("Failed", {"response": "test fail"})

    def _exploit(self):
        self.result.success({"shell": "test success"})

    def _clean(self):
        pass
