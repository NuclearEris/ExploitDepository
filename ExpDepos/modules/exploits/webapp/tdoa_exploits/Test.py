#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2021/3/10 11:23
"""
import asyncio
import base64
import json
import sys
import requests
import httpx

from TDOABase import *
from rich.progress import Progress
from ExpDepos.libs.core.base.ExploitBase import *


class Test(ExploitBase, TdoaBase):
    """
    Exploit模块实现,用户按照如下规则编写自己的Exploit
    1. 模块基本信息属性使用首字母大写方式(ex: Name or Create_Date)
    2. 属性值若有多个可以使用列表(ex:Author = ["author1", "another author"])
    3. 描述信息Description和Desc支持Markdown语法
    4. 除下列默认属性外，用户可自定义其他信息属性
    """
    Name = 'Test Exploit'  # exp名称
    Alias = 'td_oa_all_in_one'  # 漏洞别名(简洁且唯一的识别名)
    Author = 'Castiel'  # 漏洞作者
    vulType = VUL_TYPE.CODE_EXECUTION  # 漏洞类型
    category = EXP_CATEGORY.EXPLOITS.WEBAPP  # 漏洞分类
    Create_Date = '2021-07-01'  # exp编写日期
    Update_Date = '2021-07-01'  # exp更新日期
    Rank = 'Excellent'  # exp效果(可选：Excellent Great Good Normal Average Low Manual)
    AppPowerLink = 'https://www.tongda2000.com/'  # 漏洞厂商主页地址
    AppName = 'Test App'  # 漏洞应用名称
    AppVersion = '3.x - 11.6'  # 漏洞影响版本
    References = ['https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2017/MS17-010',
                  'https://nvd.nist.gov/vuln/detail/CVE-XXX-XXX',
                  'https://github.com/xxx/xxx']
    Desc = "使用一句话描述该Exploit模块的主要功能(不支持换行或Markdown语法)"
    Description = """
# Exploit文档支持Markdown语法
## This is an h2

Rich can do a pretty *decent* job of rendering markdown.

1. This is a list item
2. This is another list item
        """

    def _options(self):
        options = dict()
        options["UserName"] = OptString("", description="系统用户名", require=True)
        options["Password"] = OptString("", description="密码", require=True)
        options["notRequire"] = OptString("", description="测试非必须选项")
        return options

    def _fingers(self):
        Fingerprint = {
            "name": self.AppName,  # 漏洞应用名作为指纹名称
            "author": self.Author,  # 作者
            "version": "1.0",  # 版本号
            "type": FINGERPRINT.FP_TYPE.WEBAPP,  # 指纹类型 详情请参考指纹类型表
            "logic": "or",  # 匹配逻辑 默认为 or
            "description": "指纹描述信息",  # 描述信息
            "website": "https://www.tongda2000.com/",
            "filters": {  # 过滤器，从操作系统平台、中间件、和脚本语言3个维度进行过滤
                "platform": ['windows', 'Unix'],
                "middleware": ['apache', 'nginx'],
                "language": ['Csharp', 'PHP']
            },
            "matches": [{"url": "/tongda.ico?r={randstr()}", "hash": -759108386, "certainty": 100, "status": 200},
                        {"search": "headers", "keyword": "X-Powered-By: PHP/7.2.24-0ubuntu0.18.04.8"},
                        {"search": "headers[set-cookie]", "regex": "(aa)", "offset": 1, "version": "2.2",
                         "aim": "version"},
                        {"name": "matchName", "keyword": "test <||> referer"},
                        {"status": 200}],
            "sets": {  # 主动式匹配的一些HTTP Request设置
                "headers": {"testHeader": "testHeader{randstr(10)}"},
                "cookies": {"cname": "cValue{randstr(5,true)}"},
                "params": {"test": "bbbb"},
                "data": ""
            }
        }
        return Fingerprint

    @timeit
    def _testRequest(self, times):
        """
        测试同步请求性能

        :param times: 测试请求次数
        :return:
        """
        for x in range(times):
            response = self.request.get("/")
            assert response.status_code == 200

    async def _request(self):
        response = await self.asyncRequest.get("/")
        assert response.status_code == 200

    @asyncTimeit
    async def _testAsyncRequest(self, times):
        """
        测试异步请求性能

        :param times: 测试请求次数
        :return:
        """
        task_list = list()
        for x in range(times):
            req = self._request()
            if (sys.version_info.major, sys.version_info.micro) < (3, 7):
                task = asyncio.ensure_future(req)
            else:
                task = asyncio.create_task(req)
            task_list.append(task)
        await asyncio.gather(*task_list)

    @timeit
    def _test(self, times=10, isAsync=True):
        """
        性能测试，本方法主要测试httpx的同步和异步请求性能

        :param times: 测试请求次数
        :param isAsync:
        :return:
        """
        # 同步请求接口self.request测试

        # response = self.request.post("/test.asp", data={"test": "123456"},
        #                              files={"files":
        #                                     ("cookie.txt", bytes("hello file contents".encode("utf-8")))
        #                                     }
        #                              )
        headers = {"referer": "test referer"}
        # response = self.request.get("/", headers=headers)
        response = self.request.get("", headers=headers)
        # response = self.request.post("", files={"File": b"aaaaaaaaaaa"},
        #                              data={"test": "aaaa"}, params={"param1": "params1"})
        # console.debug("response status:{0}".format(response.status_code))
        # console.debug("response hash:{}".format(response.hash))
        # console.debug("response md5sum:{}".format(response.md5sum))
        # console.debug("response text:{}".format(response.text))
        # console.debug("response encode: {}".format(response.get_encoding()))
        # console.debug("response contains: {}".format(response.contains("rar.exe")))
        # console.debug("response bcontains: {}".format(response.bcontains(b"wwwroot")))
        # console.debug("response bcontains with str: {}".format(response.bcontains("wwwroot")))
        # console.debug("response search: {}".format(response.search("hello+word")))
        # console.debug("response server: {}".format(response.server))

        # if isAsync:
        #     asyncio.run(self._testAsyncRequest(times))
        # else:
        #     self._testRequest(times)

        # console.debug("Fingerprint Matches: {}"
        #               .format(self.fingerprint.Matches(self.asyncRequest, response)))
        mcs = []
        # with Progress() as progress:
        #     task = progress.add_task("doing match fingers....", total=len(env.fps))
        #     i = 0
        #     for fingerprint in env.fps:
        #         if i == 3000:
        #             break
        #         matches = fingerprint.Matches(requestObj=self.request, responseObj=response, mode="PASS")
        #         if matches:
        #             mcs.append({fingerprint.name: matches})
        #         progress.update(task, advance=1)
        #         # i += 1
        # console.debug(mcs)
        # console.debug(self.fpMatches(response, "PASS"))
        console.debug(self.fingerprint.Matches(self, response))

    def _verify(self):
        # 性能测试
        self._test(times=100)

        self.result.fail("Failed", {"response": "test fail"})

    def _exploit(self):
        self.result.success({"shell": "test success"})

    def _clean(self):
        pass
