# -*- coding: utf8 -*-
import sys
import json
import base64
import socket
import requests
import traceback
import contextlib
from urllib.parse import urlparse, ParseResult

SOCKET_TIMEOUT = 10
SOCKET_READ_BUFFERSIZE = 1024


def filterHeaders(headers: dict) -> dict:
    """
    过滤掉API网关添加的请求头及proxy_endpoint

    :param headers: dict headers
    :return: dicts
    """
    removeList = ["proxy_endpoint", "requestsource", "x-api-requestid",
                  "x-api-scheme", "x-b3-traceid", "x-qualifier",
                  "authorization", "date", "source", "x-consumer-id"
                  ]
    return {key: value for key, value in headers.items() if key.lower() not in removeList}


def get_socket(protocol: str) -> socket.socket:
    """
    获取socket对象

    @param protocol: socket协议
    @type protocol: str
    @return: socket对象
    @rtype: socket
    """
    socket_type = socket.SOCK_STREAM
    if protocol.upper() == "UDP":
        socket_type = socket.SOCK_DGRAM
    if protocol.upper() == "ICMP":
        socket_type = socket.SOCK_RAW
    try:
        sock = socket.socket(family=socket.AF_INET, type=socket_type, proto=socket.getprotobyname(protocol))
        sock.settimeout(SOCKET_TIMEOUT)
    except PermissionError as e:
        raise Exception(f"No permission to use socket!")
    return sock


def parse_query(query) -> dict:
    """
    解析 socket 参数

    @param query: socket URL信息中的query值
    @type query: str
    @return:
    @rtype:
    """
    query_dict = {}
    if not query:
        return query_dict
    query_list = query.split("&")
    for q in query_list:
        if "=" in q:
            index = q.index("=")
            key, value = (q[:index], q[index + 1:])
            query_dict.update({key: value})
    return query_dict


def get_datas(endpoint_url: ParseResult, event) -> bytes:
    """
    获取socket需要发送的数据

    @param endpoint_url: socket URL信息
    @type endpoint_url: ParseResult
    @param event: 云函数事件
    @type event: dict
    @return: 需要发送的数据
    @rtype: bytes
    """
    query = endpoint_url.query
    query_dict = parse_query(query)
    if "data" in query_dict:
        return base64.b64decode(query_dict["data"])
    return base64.b64decode(event['body'])


def send_data_with_tcp(client: socket.socket, host: str, port: int, data: bytes, ):
    """
    使用TCP协议发送数据并获取返回结果

    @param client: socket 对象
    @type client: socket.socket
    @param host: 主机地址
    @type host: str
    @param port: 主机端口
    @type port: int
    @param data: 需要发送的数据
    @type data: bytes
    @return: 连接状态及返回数据
    @rtype: dict
    """
    result = {"connected": False, "rev_data": b'', "error": ''}
    try:
        client.connect((host, port))
        result["connected"] = True
    except Exception as e:
        result["error"] = repr(e)    # 连接异常后将异常信息放到error中返回
        return result
    if data:
        client.send(data)
    try:
        rev = client.recv(SOCKET_READ_BUFFERSIZE)
        result["rev_data"] = rev
    except Exception as e:
        result["error"] = repr(e)    # 读取异常后将异常信息放到error中返回
        return result
    return result


def sendto_data(client: socket.socket, host: str, port: int, data: bytes):
    """
    使用socket.sendto() 发送ICMP或者UDP协议数据

    @param client: socket 对象
    @type client: socket.socket
    @param host: 主机地址
    @type host: str
    @param port: 主机端口
    @type port: int
    @param data: 需要发送的数据
    @type data: bytes
    @return: 连接状态及返回数据
    @rtype: dict
    """
    result = {"connected": False, "rev_data": b'', "error": ''}
    try:
        client.sendto(data, (host, port))
        result["connected"] = True
    except Exception as e:
        result["error"] = repr(e)   # 发送异常后将异常信息放到error中返回
    try:
        rev, address = client.recvfrom(SOCKET_READ_BUFFERSIZE)
        if rev and address:
            result["rev_data"] = rev
    except Exception as e:
        result["error"] = repr(e)    # 读取异常后将异常信息放到error中返回
        return result
    return result


def send_data(client: socket.socket, host: str, port: int, data: bytes, protocol: str) -> dict:
    """
    发送数据并获取返回结果

    @param client: socket 对象
    @type client: socket.socket
    @param host: 主机地址
    @type host: str
    @param port: 主机端口
    @type port: int
    @param data: 需要发送的数据
    @type data: bytes
    @param protocol: socket 协议
    @type protocol: str
    @return: 连接状态及返回数据
    @rtype: dict
    """
    if protocol.upper() == "TCP":
        return send_data_with_tcp(client, host, port, data)
    return sendto_data(client, host, port, data)


def proxy_sockets(endpoint_url, event):
    """
    socket 代理请求

    @param endpoint_url: 请求目的地URL
    @type endpoint_url: ParseResult
    @param event: 云函数事件
    @type event: dict
    @return:
    @rtype:
    """
    host = endpoint_url.hostname
    port = endpoint_url.port
    if not port:
        port = 0
    protocol = endpoint_url.path[1:]
    if not protocol:
        protocol = "TCP"
    data = get_datas(endpoint_url, event)
    try:
        with contextlib.closing(get_socket(protocol)) as client:
            result = send_data(client, host, port, data, protocol)
        if not result["connected"]:
            return proxy_failed(f"socket connection failed: {result['error']}", event)
        resp = {
            "isBase64Encoded": True,
            "statusCode": 0,
            "connected": result["connected"],
            "headers": "",
            "body": base64.b64encode(result["rev_data"]).decode(),
            "request": ""
        }
    except Exception as e:
        return proxy_failed(repr(e), event)
    return resp


def proxy_http(endpoint, endpoint_url, event):
    headers = filterHeaders(event["headers"])
    # 更改请求头中的host值
    headers["host"] = endpoint_url.netloc
    if not endpoint_url.scheme:
        endpoint = "http://" + endpoint
    try:
        data = base64.b64decode(event['body']) if 'body' in event else ''
        params = event['queryString'] if 'queryString' in event else ''
        response = requests.request(event["httpMethod"],
                                    url=endpoint,
                                    headers=headers,
                                    data=data,
                                    params=params,
                                    verify=False
                                    )
    except Exception as e:
        return proxy_failed(f"Try to request {endpoint} failed! Exception: {repr(e)}", event)
    resp = {
        "isBase64Encoded": True,
        "statusCode": response.status_code,
        "headers": json.dumps(dict(response.headers)),
        "body": str(base64.b64encode(response.content), encoding="UTF-8"),
        "request": json.dumps({"url": endpoint, "headers": headers, "params": params})
    }
    return resp


def proxy_failed(message: str, event, status_code=-1):
    exc_type, exc_value, exc_traceback = sys.exc_info()
    if exc_traceback:
        exc_traceback = repr(traceback.format_tb(exc_traceback))
    else:
        exc_traceback = ''

    return {
        "isBase64Encoded": False,
        "statusCode": status_code,
        "headers": json.dumps(event["headers"]),
        "body": json.dumps(message + "\n" + exc_traceback),
        "request": ""
    }


def main_handler(event, context):
    if "proxy_endpoint" not in event["headers"]:
        return proxy_failed("Please set the URL in the proxy_endpoint parameter of the request headers.", event)
    endpoint = event["headers"]["proxy_endpoint"]
    endpoint_url = urlparse(endpoint)
    if not endpoint_url.hostname and not endpoint_url.geturl():
        return proxy_failed(f"invalid proxy endpoint: {endpoint}", event)
    if endpoint_url.scheme == "sock":
        return proxy_sockets(endpoint_url, event)
    return proxy_http(endpoint, endpoint_url, event)
